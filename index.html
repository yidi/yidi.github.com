<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>


    <meta name="description" content="JEE Dadabase BigData Hadoop Spark" />



  <meta name="keywords" content="YIDI'S BLOG" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> YIDI'S BLOG </title>
</head>

<body>
  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->

  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">YIDI'S BLOG</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<div class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            <i class="menu-item-icon icon-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            <i class="menu-item-icon icon-about"></i> <br />
            关于
          </a>
        </li>
      
    </ul>
  

  
</div>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/19/Java并发编程（六）-任务调度框架/">
                Java并发编程(六)-任务执行框架
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-19
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/19/Java并发编程（六）-任务调度框架/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/19/Java并发编程（六）-任务调度框架/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>Executor是最基本的任务执行框架，其子接口ExecutorService提供了更加丰富的功能，而ThreadPoolExecutor是其中最重要最常用的实现方式。Executors提供了丰富的方便的工厂方法用于获取Executor及其他有用的工具，下面我们就详细介绍这些工具。</p>
<h2 id="Executor">Executor</h2><p>它只有一个方法void execute(Runnable command);<br>用于在将来的某一时刻执行给定的command，而command具体的执行方式取决于Executor的具体实现方式，也许是在一个新线程里执行，也许是在一个线程池里执行，也许就是用调用线程本身去执行。</p>
<p>Executor用于执行提交给其的runnable(),使任务本身与任务的如何执行解耦开来（包括线程使用和调度的细节）。使任务的执行机制更加灵活。<br>例如一般的我们应该使用</p>
<pre><code>Executor executor = anExecutor<span class="comment">;</span>
executor.execute(new RunnableTask())<span class="comment">;</span>
</code></pre><p>而不是使用</p>
<pre><code><span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span>(<span class="type">RunnableTask</span><span class="literal">()</span>)).start<span class="literal">()</span>;
</code></pre><h2 id="ExecutorService">ExecutorService</h2><p>ExecutorService是Executor的子接口，它提供了更多的特性，我们可以关闭服务而不再接受新的任务的提交和执行。<br>submit()方法则比execute()方法更强大，它创建并返回一个Future对象，通过Future对象可以取消任务的执行或者等待任务的完成。或者在任务完成后获取执行结果等操作。</p>
<h2 id="ThreadPoolExecutor">ThreadPoolExecutor</h2><p>线程池要解决两个问题：</p>
<p>1.在执行大量的线程时，通过减少每个任务调用的开销以提供性能，并且提供了在执行任务集合时绑定及管理资源（包括线程资源）的一些方法。</p>
<p>2.维护基本的统计信息。</p>
<p>ThreadPoolExecutor继承自AbstractExecutorService，并实现了Executor,ExecutorService。</p>
<p>为了能广泛使用，ThreadPoolExecutor提供了很多可调用参数和扩展空间，一般情况下使用Executors的工厂方法来获取线程池执行器就足够了，如需要手工配置就需要了解其构造函数形式，ThreadPoolExecutor提供了以下几个构造参数：</p>
<pre><code>ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 
</code></pre><p>相对于最后一个构造器，其缺少最后两个参数：ThreadFactory，RejectedExecutionHandler，这里使用并发包提供的对应的默认实现。</p>
<pre><code>ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler <span class="keyword">handler</span>) 
</code></pre><p>相比第一个构造器，使用这个构造器需要指定特定的RejectedExecutionHandler。</p>
<pre><code>ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) 
</code></pre><p>相比第一个构造器，使用这个构造器需要指定特定的ThreadFactory。</p>
<pre><code>ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler <span class="keyword">handler</span>)  
</code></pre><p>这个构造器需要提供所有参数，分别为：池内核心线程数corePoolSize，池内最大线程数maximumPoolSize，存活时间keepAliveTime，时间单位timeUnit，待调度工作队列workQueue，及拒绝执行处理器handler。</p>
<h3 id="线程数">线程数</h3><p>如果一个新的任务被提交到executor方法</p>
<h4 id="当前池内线运行线程数少于corePoolSize">当前池内线运行线程数少于corePoolSize</h4><p>线程池就会创建一个新的线程去处理这个请求，即使运行线程中部分是空闲状态。</p>
<h4 id="当前池内运行线程数大于corePoolSize而少于maximumPoolSize">当前池内运行线程数大于corePoolSize而少于maximumPoolSize</h4><p>只有工作队列满的时候才会去创建一个新的线程，否则把当前任务添加到待调度工作队列。</p>
<h4 id="当前池内运行线程数已经是maximumPoolSize">当前池内运行线程数已经是maximumPoolSize</h4><p>会触发RejectedExecutionHandler的处理，接下来我们再说明具体策略。</p>
<p>如果我们把corePoolSize设置的和maximumPoolSize一样大，就表示创建了一个固定尺寸的线程池，如果maximumPoolSize设置为一个实际意义上的无限值，例如Integer.MAX_VALUE，就表示线程池可以容纳任意数目的任务数。</p>
<p>通常只在构造ThreadPoolExecutor时通过构造器设置corePoolSize和maximumPoolSize，但是也可以通过setCorePoolSize(int)和setMaximumPoolSize(int)方法在运行时动态设置和改变。</p>
<h3 id="存活时间">存活时间</h3><p>如果当前运行的线程数目大于corePoolSize，则超过这个这个数目的线程如果空闲事件超过了keepAliveTime 指定的长度就会被终止。这样在当前线程池不是很活跃的时候有效的减少了系统资源的消耗。之后如果线程池再次活跃起来，再去创建新的线程。这个参数配合TimeUnit unit参数一起使用。</p>
<h3 id="待调度工作队列">待调度工作队列</h3><p>其可以用来传递和保持提交任务，workQueue的使用与线程池的大小相关</p>
<h4 id="线程池内运行的线程少于corePoolSize">线程池内运行的线程少于corePoolSize</h4><p>直接创建一个新线程去处理任务，而不去排队。</p>
<h4 id="线程池内运行的线程大于等于corePoolSize">线程池内运行的线程大于等于corePoolSize</h4><p>如果线程池队列未满就把任务添加到队列。否则，如果队列已满。则当前运行线程小于maximumPoolSize，则新建一个线程。 当前运行线程已经是maximumPoolSize，则任务会被拒绝，触发RejectedExecutionHandler。</p>
<p>workQueue有以下几种一般性的策略</p>
<h4 id="Direct_handoffs">Direct handoffs</h4><p>workQueue一个好的默认选择就是使用一个同步队列直接将任务传递给线程，而不去持有任务，因此如果当前没有线程立即可用去执行任务时，试图再给workQueue添加任务就会失败。这一策略在处理一系列有内部依赖关系的任务时可以避免死机。Direct handoffs通常要求一个无界的maximumPoolSizes一避免拒绝新提交的任务。这样导致的一个问题就是，如果新提交的任务速度快于任务被处理的速度就会导致无限的线程增长。</p>
<h4 id="Unbounded_queues">Unbounded queues</h4><p>Direct handoffs依赖于当前可用的线程数量.而Unbounded queues就是当corePoolSize都忙时新的任务就会被排队到队列中，也及maximumPoolSize此时是没有作用的，这在那种任务之间彼此独立且相互不影响其他任务执行的时候有作用。，如果新提交的任务速度快于任务被处理的速度就会导致队列长度的无限增长。</p>
<h4 id="Bounded_queues">Bounded queues</h4><p>Bounded queues顾名思义就是排队队列是有界限的，不能无限增长，通过与有界的maximumPoolSizes配合可以避免资源耗尽，但是这种场景很难控制。<br>如果使用较小的maximumPoolSizes和较大的workQueue就会减少CPU使用率、系统资源和上下文切换开销，但是如果任务是IO密集型，则队列会一直增张，而系统资源就会大量空闲，从而显著的降低系统吞吐量。</p>
<p>如果使用较大的maximumPoolSizes和较小的workQueue就会使CPU使用率攀升，同样可能导致不可接收的调度任务开销，从而降低系统吞吐量。</p>
<h3 id="线程工厂">线程工厂</h3><p>线程都是通过ThreadFactory创建的，而如果没有指定，默认的使用Executors.defaultThreadFactory() 创建的线程工厂，我们接下来再具体介绍这个默认实现。如果ThreadFactory创建线程失败，执行器可以保持正常的状态，但是不能执行任何任务。<br>而如果指定了特定的ThreadFactory实现，就会用指定的ThreadFactory创建线程。</p>
<h4 id="ThreadFactory">ThreadFactory</h4><p>ThreadFactory是一个只有一个方法的接口newThread(Runnable r) 返回一个Thread对象，ThreadFactory的实现定制了线程的创建方式。在newThread()里可以初始化优先级，线程名、守护状态、线程组等。<br>Executors.defaultThreadFactory()实现了一个默认的ThreadFactory工厂。在讲解Executors在具体说明。</p>
<h3 id="拒绝执行处理器">拒绝执行处理器</h3><p>如果Executor已经关闭，或者Executor池中的线程数和工作队列都已经饱和了，再提交到execute()方法的任务就会被拒绝。execute()方法就会调用其RejectedExecutionHandler的rejectedExecution()方法。JDK提供了4个预定义的RejectedExecutionHandler：</p>
<h4 id="ThreadPoolExecutor-AbortPolicy">ThreadPoolExecutor.AbortPolicy</h4><p>直接抛出一个运行时异常RejectedExecutionException。</p>
<h4 id="ThreadPoolExecutor-CallerRunsPolicy">ThreadPoolExecutor.CallerRunsPolicy</h4><p>调用execute()的线程自身去运行对应的任务。这样就提供了一个简单的反馈控制机制(feedback control mechanism)降低任务被提交的频率。</p>
<h4 id="ThreadPoolExecutor-DiscardPolicy">ThreadPoolExecutor.DiscardPolicy</h4><p>简单的丢弃不能被执行的任务。</p>
<h4 id="ThreadPoolExecutor-DiscardOldestPolicy">ThreadPoolExecutor.DiscardOldestPolicy</h4><p>如果Executor还没有关闭，待调度工作队列对头的被丢弃，然后重试。</p>
<p>也可以自定义并使用其他的RejectedExecutionHandler实现。但是需要特别小心，特别是自定义的机制设计为特定的容量或队列策略实现时。</p>
<h3 id="扩展性">扩展性</h3><p>提供了受保护的方法beforeExecute(java.lang.Thread, java.lang.Runnable) 和afterExecute(java.lang.Runnable, java.lang.Throwable) 这两个方法分别为在执行任务前后执行，这非常有用，可以覆盖，例如用于在执行前后配置环境信息，获取统计量，记日志等。同样还有一个可覆盖的方法terminated()，这个方法在Executor被完全关闭后调用，在这里我们可以做任何需要做的特定的处理。</p>
<h2 id="Callable">Callable<v></v></h2><p>ExecutorService的submit()方法可以接收Callable对象，与Runnable一样，都是被一个线程去执行，而Runnable不返回值也抛出已检查异常，对应的Callable也只有一个方法：<code>V call()</code><br>其会返回一个值，并且在执行失败时会返回一个异常。</p>
<h2 id="Future">Future</h2><p>ExecutorService的submit()方法接收一个Callable对象，而返回一个Future<t>对象，其代表异步计算的结果。其中Future<t>中的T就是Callable.call()返回的值，通过get()方法获取计算结果。get()检查异步任务是否完成，如果完成就获取计算结果，如果没有完成就阻塞，直到计算结果完成。Future<t>一共提供了以下几个方法，这几个方法可以配合使用。</t></t></t></p>
<h3 id="Future方法列表">Future<t>方法列表</t></h3><p>cancel(boolean mayInterruptIfRunning) 尝试徐晓任务的执行，如果任务已经完成，则不能被取消。<br>get() 等待计算完成，然后获取计算结果。<br>isCancelled() 如果任务在计算完成之前被取消，则返回true。<br>isDone() 如果任务完成了返回true。</p>
<p>FutureTask是Future<t>接口的一个基本实现，同时FutureTask也实现了Runnalbe接口</t></p>
<h2 id="Executors">Executors</h2><p>是并发包中提供的强大的工厂类，通过调用其中的静态工厂方法能获得大部门常用的工具。</p>
<h3 id="获取线程池">获取线程池</h3><p>public static ExecutorService newFixedThreadPool(int nThreads)<br>更具参数指定的数目创建并返回一个拥有nThreads个线程和一个无解队列的线程池，如果在执行过程中有任何线程失败了，如果需要执行新的任务则会创建一个新的线程。</p>
<p>public static ExecutorService newFixedThreadPool(int nThreads,                                                 ThreadFactory threadFactory)<br>与上一个类似，区别是线程通过指定的threadFactory创建。</p>
<p>public static ExecutorService newSingleThreadExecutor()<br>与第一个类似，不同的是只创建拥有一个线程的线程池，这样就保证任务是根据被提交的顺序执行的。<br>newFixedThreadPool(1)与其功能相同，但是不同的是 newSingleThreadExecutor()不能重新设定线程数量。</p>
<p>public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)<br>与上一个类似，区别是线程通过指定的threadFactory创建。同样其不能重新设定线程数量。</p>
<p>public static ExecutorService newCachedThreadPool()<br>创建一个线程池，其中线程数量根据需要创建，而没有限制，这样的线程池适合执行时间短的任务，任何空闲6秒中的线程都将被回收。其实就是corePoolSize = 0, maximumPoolSize = Integer.MAX_VALUE keepAliveTime=60  TimeUnit = TimeUnit.SECONDS的线程池。</p>
<p>public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)<br>与上一个类似，区别是线程通过指定的threadFactory创建。</p>
<p>public static ScheduledExecutorService newSingleThreadScheduledExecutor()<br>创建拥有一个线程的线程池，并且可以调度命令在指定的延时或者周期执行。同样的不能重新设定线程数量。</p>
<p>public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory)<br>与上一个类似，区别是线程通过指定的threadFactory创建。</p>
<p>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)<br>与上面的类似，但是创建池内要时刻存活的线程数量为corePoolSize。</p>
<p>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize,<br>ThreadFactory threadFactory)<br>与上一个类似，区别是线程通过指定的threadFactory创建。</p>
<p>public static ExecutorService unconfigurableExecutorService(ExecutorService executor)<br>相当与强行将给定的任意类型的ExecutorService实现都转换为ExecutorService对象，这样就安全的冻结了那些调整操作，从而不允许对线程池进行调整。例如：</p>
<pre><code>ThreadPoolExecutor exec = new ThreadPoolExecutor<span class="params">(<span class="number">0</span>, Integer.MAX_VALUE,
            <span class="number">60</span>L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;<span class="params">()</span>)</span>;
exec.setCorePoolSize<span class="params">(<span class="number">10</span>)</span>;<span class="comment">//可以调整</span>
<span class="comment">//不可以调整</span>
ExecutorService execServ = Executors.unconfigurableExecutorService<span class="params">(exec)</span>;
</code></pre><p>public static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor)<br>与上一个类似，区别是参数和返回的都是一个ScheduledExecutorService。</p>
<p>同时Executors还提供了其他的创建线程工厂和Callable对象的方法。具体用法可以参考对应的API。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/16/Java并发编程（五）-Java并发包概览/">
                Java并发编程(五)-并发包概览
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-16
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/16/Java并发编程（五）-Java并发包概览/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/16/Java并发编程（五）-Java并发包概览/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>前面我们学习了Java并发提供的最底层的并发原语：<code>synchronized, volatile, wait(), notify(), and notifyAll()</code>，这些原语真正使用起来的时候会很复杂，并很容易产生死锁，饥饿及条件竞争等。从JDK5开始，Java原生提供了并发工具类库java.util.concurrent包用于支持并发编程，以提供高效的，高可用的，可维护的并发工具。<br>本篇整体介绍下JDK5引入的并发包工具及包的组织结构，接下来针对各组件分别进行重点介绍。</p>
<h2 id="Java并发包提供的功能">Java并发包提供的功能</h2><p>并发包中提供了：线程池）、任务异步执行框架、为并发访问而优化的集合类型、计数信号量等同步机制 、原子变量、锁机制以及条件变量等。</p>
<h3 id="任务调度框架(Task_Scheduling_Framework)">任务调度框架(Task Scheduling Framework)</h3><p>执行框架可以通过一系列的执行策略来规范异步任务的调用、调度、执行及控制。框架实现允许在提交的线程中执行任务。例如一个单一的后台线程、一个新建的线程或者一个线程池。开发者可以创建支持任意执行策略的执行器。内置的实现提供可配置的策略，例如队列长度及饱和策略，这可以提高可用性，防止资源不可控的过度消耗。</p>
<h3 id="并发集合(Concurrent_Collections)">并发集合(Concurrent Collections)</h3><p>在并发包中提供了一些新的集合，包括新的Queue和BlockingQueue以及一些高性能的Map、List等的并发实现。</p>
<h3 id="原子类型(Atomic_Variables)">原子类型(Atomic Variables)</h3><p>这里是一些对单个基本类型或者引用类型的原子操作的类库，提供高性能的原子运算和CAS(compare-and-set )方法.这些对实现高性能的并发算法很有用，同时也为实现计数器和序列生成器提供了方便。</p>
<h3 id="同步器(Synchronizers)">同步器(Synchronizers)</h3><p>提供了一些简化线程间协作通信的工具，包括semaphores, mutexes, barriers, latches,及 exchangers等。</p>
<h3 id="锁机制(Locks)">锁机制(Locks)</h3><p>Java语言通过synchronized关键字内嵌锁机制的，但是内置锁有很多不便的限制。并发包中的Locks在内存语义上和内置的synchronized是一致的，但是可以支持在获取锁的时候指定超时参数（timeout）、每个锁都可以有多个条件变量、非词法作用域(non-lexically)锁、支持中断正在等待获取锁的线程,而这正是synchronized不具备的。</p>
<h3 id="纳秒粒度的时序(Nanosecond-granularity_timing)">纳秒粒度的时序(Nanosecond-granularity timing)</h3><p>System.nanoTime()可以访问纳秒粒度的时间，用于相对时间测量，对于那些接受超时参数的方法来说也提供纳秒粒度的超时监测。</p>
<h2 id="包结构">包结构</h2><p>在Java5中有以下三层包结构：</p>
<p><code>java.util.concurrent 
java.util.concurrent.atomic
java.util.concurrent.locks</code></p>
<h3 id="java-util-concurrent">java.util.concurrent</h3><p>这里是并发编程常用的工具、一些小的可扩展框架、一些有用的或者繁琐、难以实现的功能。</p>
<h4 id="Executors">Executors</h4><p><strong>接口：</strong><br><code>Executor</code>：是一个只提供了一个execute()方法的简单的调度自定义线程子系统的标准接口（包括线程池，异步IO）及轻量级的任务框架。根据Executor的具体实现，任务可以有不同的执行方式。<br><code>ExecutorService</code> ：提供了一个更完整的异步任务执行框架，管理任务的队列及调度并且允许关闭服务。<br><code>ScheduledExecutorService</code>子接口增加了对延时和周期性任务执行的支持。</p>
<p><strong>实现：</strong><br><code>ThreadPoolExecutor</code> 和<code>ScheduledThreadPoolExecutor</code>提供了灵活的线程池。<br><code>Executors</code>类提供工厂方法用于最常用的Executors种类和配置。<br><code>FutureTask</code>提供了通用的可扩展实现Futures。<br><code>ExecutorCompletionService</code>协助处理异步任务组的处理。</p>
<h4 id="Queues">Queues</h4><p><code>ConcurrentLinkedQueue</code>提供非阻塞的线程安全的FIFO队列，而BlockingQueue接口的5个实现则定义了阻塞版本的put()和take().这些类基本上覆盖了常用的生产者-消费者模式，消息、并行任务等相关并发设计。</p>
<h4 id="Timing">Timing</h4><p><code>TimeUnit</code>类提供了包括纳秒在内的多种粒度用于指定和控制基于超时的操作。包中大多数的类都包含基于超时参数的操作以避免不确定的等待。所有使用超时的操作，超时参数表示操作在表明超时前需要等待的最小时间，这些实现都尽力在超时一旦发生后就检测到。但是在实际检测到超时及线程在超时后再次执行时还是会有一段不确定的时间流失。</p>
<h4 id="Synchronizers">Synchronizers</h4><p>有四个类去实现同步原语。<br><code>Semaphore</code>:一个经典的并发工具。<br><code>CountDownLatch</code>： 是一个非常简单但很常用的实用程序，它会一直阻塞，直到获得了给定数目的信号，事件或条件后才继续执行。<br><code>CyclicBarrier</code>：是一个可复位的多路同步点。<br><code>Exchanger</code>：允许两个线程在某个点交换持有的对象，在一些管道设计中很常用。</p>
<h4 id="Concurrent_Collections">Concurrent Collections</h4><p>这里主要是用于多线程环境中的一些集合的实现，这里的“Concurrent”    前缀和那些一般意义上的线程安全的集合例如Hashtable，synchronizedMap是不一样的，这里的“Concurrent”也是线程安全的，但是不是通过一个单一的排他锁支配的。ConcurrentHashMap可以保证任意数量的并发读操作及一定数目的并发写操作的安全性，“Synchronized”类型在我们需要通过单一的锁阻止所有对集合的访问时是很有用的，但是在那些需要多个线程同时访问集合的情况下，“Concurrent”类型更合适，而如果集合是独享的，或者是在持有某些锁后才能访问集合时，普通的非线程安全的集合是最好的。<br>同样的“Concurrent”集合的迭代器不同于普通集合，“Concurrent”的迭代器提供的是弱一致性的迭代器，而不像普通集合那样提供强一致性的迭代器，也即，如果是在“Concurrent”集合上进行迭代时，是可以对集合进行更新的，而在普通集合迭代期间，一旦有更新就会导致迭代失败。</p>
<p>在java.util.concurrent包下还有两个子包java.util.concurrent.atomic和java.util.concurrent.locks分别对应的是原子操作的实现和锁实现，在后面会详细进行介绍。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/12/Java并发编程（四）-线程协作/">
                Java并发编程(四)-线程协作
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-12
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/12/Java并发编程（四）-线程协作/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/12/Java并发编程（四）-线程协作/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>在前面我们通过互斥量同步多个任务的行为，从而保证一个任务不会被另一个任务干扰，通过互斥可以保证在任何时候只有一个任务在访问共享资源。在并发任务中，更重要的是任务之间的协作，使得多个任务可以协作共同解决一个问题。任务之间并不是彼此干涉的，而是彼此协调的，这些任务有先后顺序和依赖，也有可以并行执行的。任务的协作还是依靠基本的基础特性：互斥。并在此基础之上添加了一种途径，任务可以在一定条件下将自身挂起，直到外部条件变化可使当前任务继续向前执行为止。</p>
<h2 id="1-wait()、notify()">1.wait()、notify()</h2><p>在线程上调用wait()方法表示当前线程已经完成了所能做的事情，需要在此等待，wait()操作会将当前线程挂起，并释放锁，这样其他线程就可以访问该锁上的其他synchronized锁资源了。（wait()操作是释放锁的，而sleep()和yield()并不释放锁）.wait()操作等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力。通常这个条件需要另一个任务来改变。wait()可以接受一个超时参数也可以无参数表示一直等待下去。直到另一个任务通过notify()或者notifyAll()将其唤醒。</p>
<p>注：只能在同步控制块中使用wait()/notify()/notifyAll()等操作，因为如果不是在同步控制块中调用，虽然能通过编译，但是在运行时会抛出IllegalMonitorStateException异常。表示任务在调用这些方式前必须拥有（获得）锁。不存在锁的话也就不存在这些操作了。</p>
<p>notify()或者notifyAll会唤醒等待该对象的锁的其他任务，但是不同的任务可能是由于不同的原因产生等待的，因此有可能被唤醒的任务此时其等待的条件并没有满足，因此需要在继续向前执行前判断下其感兴趣的条件是否发生，如果发生才向前执行，否则继续等待，一般情况下惯用的方式是通过while循环去编写这样的代码。例如有两个线程在等待同一个对象的锁，但是等待的条件并不相同，第三个线程通过调用notifyAll()将这两个线程同时唤醒，但是只有其中一个线程的条件满足可以继续向前执行，另一个线程检测到当前唤醒时条件依旧不满足(此线程由于不正确的原因被唤醒)，则因继续调用wait()进行等待。</p>
<p>在JDK5中还可以通过在Condition 上调用await()来挂起任务，调用signal()/signalAll()来实现通知任务可以继续执行，用法和wait()/notify()/notifyAll()类似。使用时需要显示的使用Lock和Condition对象。现在，实际项目中更多的是使用Condition/Lock组合而很少使用wait()/notify()/Synchronized了。</p>
<pre><code><span class="operator"><span class="keyword">Lock</span> <span class="keyword">lock</span> = new Reentrantlock();</span>
Condition condition = <span class="operator"><span class="keyword">lock</span>.newCondition();</span>
</code></pre><h2 id="2-丢失的信号">2.丢失的信号</h2><p>当两个线程通过wait()和notify()/notifyAll()进行协作时，可能会错过某个信号，如下所示：T1是通知T2的线程，而这两个线程（有缺陷）的实现如下：</p>
<pre><code>T1：
    <span class="keyword">synchronized</span>(<span class="keyword">this</span>){
        &lt;setup condition <span class="keyword">for</span> T2&gt;
        notify();
    }
T2:
    <span class="keyword">while</span>(some condition){
        <span class="comment">//Point1</span>
        Synchronized{
            wait();
        }
    }
</code></pre><p><code>&lt;setup condition for T2&gt;</code>是防止T2进行wait()的一个动作，前提是T2还没有调用wait()操作。假设T2判断<code>some condition</code>为true就会进入while循环体。此时在Point1处线程调度器被切换到执行T1，然后T1调用notify()，此时对于T2来说条件已经发生了变化，即<code>some condition</code>求值结果可能已经为false，不应进行wait(),而此时对于T2来说已经太晚了，不能意识到这个条件已经发生了变化，因此会盲目进入wait()。从而错过这个notify()，而T2也就会无限的等待这个已经发送过的信号，从而产生死锁。</p>
<p>该问题的解决方式是防止在some condition条件上产生竞争条件，下面是T2正确的执行方式(双检查锁)：</p>
<pre><code>T2:
    <span class="keyword">while</span>(some <span class="keyword">condition</span>){
        <span class="comment">//Point1</span>
        Synchronized{
          <span class="keyword">while</span>(some <span class="keyword">condition</span>)
            wait();
        }
    }
</code></pre><p>注：使用notifyAll()比使用notify()更安全，但是使用notify()是一种优化，为了使用notify()必须保证：1.所有的任务都是等待相同的条件，否则就不能保证是否唤醒了正确的任务。2.当条件发生变化时，必须只有一个任务受益。3.这些限制对所有可能的子类也必须同样起作用。notifyAll()唤醒所有因等待同一个特定锁而被阻塞的所有任务，而不是唤醒所有正在等待的阻塞任务。</p>
<h2 id="3-生产者与消费者">3.生产者与消费者</h2><p>生产者消费者问题是经典的线程协作场景，只有当生产者生产出产品后消费者才可以消费产品，一般的生产者和消费者分别是不同的任务，其中的产品通过一个共享的队列或者其他形式的方式实现，生产者和消费者需要在这个共享的产品结构上进行同步以实现生产者消费者模型。</p>
<p>例如在一个餐馆中，厨师代表生产者用来生产食物，服务员代表消费者用来将厨师做的食物端给客户消费。餐馆一开始营业厨师就和服务员开始各司其职，代码如下：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Restaurant</span> {
    <span class="keyword">private</span> Meal meal;
    <span class="keyword">private</span> ExecutorService  exec = <span class="keyword">null</span>;
    <span class="keyword">private</span> WaitPerson waitPerson =<span class="keyword">null</span>;
    <span class="keyword">private</span> Chief chef =<span class="keyword">null</span>;
    <span class="function"><span class="keyword">public</span> <span class="title">Restaurant</span>(<span class="params"></span>)</span>{
        waitPerson = <span class="keyword">new</span> WaitPerson(<span class="keyword">this</span>);
        chef = <span class="keyword">new</span> Chief(<span class="keyword">this</span>);
        exec = Executors.newCachedThreadPool();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span>(<span class="params"></span>)</span>{
        exec.execute(waitPerson);
        exec.execute(chef);
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        Restaurant restaurant = <span class="keyword">new</span> Restaurant();
        restaurant.open();
    }
}
</code></pre><p>new Restaurant()表示创建餐馆，其中有厨师Chief和服务员WaitPerson，还有饭菜Meal exec表示执行餐馆业务的基本条件。调用open()方法表示餐馆开始营业即厨师和服务员开始忙碌，各司其职。其中厨师chief和服务员waitPerson都是实现了Runnable接口的可运行的任务。其中饭菜就是厨师和服务员需要协作的工作，其实现如下：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Meal</span></span>{
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> orderNumber;
    <span class="function"><span class="keyword">public</span> <span class="title">Meal</span><span class="params">(<span class="keyword">int</span> orderNumber)</span></span>{
        <span class="keyword">this</span>.orderNumber = orderNumber;
    }
    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="string">"Meal"</span> + orderNumber;
    }
}
</code></pre><p>厨师和服务员被设计为可执行任务，分别执行具体的动作，厨师只有在当前Meal为空的时候开始做饭，服务员在厨师做饭的时候等待，厨师做好饭后通知服务员取餐，在服务员将饭菜取走之前厨师将等待，直到服务员将饭菜取走并通知其继续做饭厨师再开始做饭。服务员和厨师的实现代码如下：</p>
<pre><code><span class="keyword">class</span> WaitPerson <span class="keyword">implements</span> Runnable{
    <span class="keyword">private</span> Restaurant r;
    <span class="keyword">public</span> WaitPerson(Restaurant r){
        <span class="keyword">this</span>.r = r;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> run(){
        <span class="keyword">try</span>{
            <span class="keyword">while</span>(!Thread.interrupted()){
                <span class="keyword">synchronized</span>(<span class="keyword">this</span>){
                    <span class="keyword">while</span>(r.meal == <span class="keyword">null</span>){
                        wait();
                    }
                }
                System.out.<span class="keyword">println</span>(<span class="string">"Waitperson got "</span> + r.meal);
                <span class="keyword">synchronized</span>(r.chef){
                    r.meal = <span class="keyword">null</span>;
                    r.chef.notifyAll();
                }
            }
        }<span class="keyword">catch</span>(InterruptedException e){
            System.out.<span class="keyword">println</span>(<span class="string">"WaitPerson interrupted!"</span>);
        }
    }
}

<span class="keyword">class</span> Chief <span class="keyword">implements</span> Runnable{
    <span class="keyword">private</span> Restaurant restaurant;
    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;
    <span class="keyword">public</span> Chief(Restaurant r){
        <span class="keyword">this</span>.restaurant = r;
    }
    <span class="keyword">public</span> <span class="keyword">void</span> run(){
        <span class="keyword">try</span>{
            <span class="keyword">while</span>(!Thread.interrupted()){
                <span class="keyword">synchronized</span>(<span class="keyword">this</span>){
                    <span class="keyword">while</span>(restaurant.meal != <span class="keyword">null</span>){
                        wait();
                    }
                }
                <span class="keyword">if</span>(++<span class="keyword">count</span> == <span class="number">10</span>){
                    System.out.<span class="keyword">println</span>(<span class="string">"Out of food. Closing"</span>);
                    restaurant.exec.shutdownNow();
                }
                System.out.<span class="keyword">println</span>(<span class="string">"Order up!"</span>);
                <span class="keyword">synchronized</span>(restaurant.waitPerson){
                    restaurant.meal = <span class="keyword">new</span> Meal(<span class="keyword">count</span>);
                    restaurant.waitPerson.notifyAll();
                }
                TimeUnit.SECONDS.sleep(<span class="number">1</span>);
            }
        }<span class="keyword">catch</span>(InterruptedException e){
            System.out.<span class="keyword">println</span>(<span class="string">"Chef interrupted!"</span>);
        }
    }
}
</code></pre><p>可以看到厨师在检测是否需要做饭的时候要在其自身对象上同步，以保证做饭的互斥性，即在做饭的时候服务员不会过来取餐。在具体做饭的时候需先获取waitPerson对象上的锁，这样在做好饭之后就可以通过notifyAll通知waitPerson取餐了。服务员对应的逻辑与厨师相同。</p>
<p>wait()/notify()以低级的方式解决了任务协作问题，每次任务交互都需要握手，这样虽然可能更好的理解任务同步的具体执行过程，但是却陷入了复杂的具体的代码实现上，而且这种控制起来也更加困难，一旦业务规则复杂起来，类和类之间的耦合性就会非常复杂，就很容易出问题。</p>
<p>其实在Java并发包中可以使用同步队列来解决任务协作问题，同步队列任何时候都只允许有一个任务进行插入或移除元素。当消费者任务试图从队列中获取元素，而队列为空时，这些队列可以自动挂起消费者任务。并等到有的元素可用时恢复消费者任务。同步队列比起wait()/notify()简单并可靠的多。在java.util.concurrent,BlockingQueue提供了这个接口，并且有大量的标准实现。例如：<br>LinkedBlockingQueue,ArrayBlockingQueue,SynchronousQueue等。使用BlockingQueue可以极大的简化程序的实现，因为队列的阻塞，使得处理过程被自动的挂起和恢复，而不用显示的调用wait()/notify()，每个类只和它自己的BlockingQueue通信，因此类和类之间的耦合性也被消除了。下面看一个使用同步队列实现生产者与消费者任务的示例，其中土司面包有三道工序，依次为做土司，抹黄油，涂果酱，并且只有在这三道工序完成之后才可以吃。完整代码如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastOMatic</span> </span>{
    <span class="keyword">private</span> ToastQueue dryQueue,butteredQueue,finishedQueue;
    ExecutorService exec;
    <span class="keyword">public</span> <span class="keyword">enum</span> Status {
        DRY, BUTTERED, JAMMED
    }
    <span class="function"><span class="keyword">public</span> <span class="title">ToastOMatic</span><span class="params">()</span></span>{
        <span class="keyword">this</span>.dryQueue = <span class="keyword">new</span> ToastQueue();
        <span class="keyword">this</span>.butteredQueue = <span class="keyword">new</span> ToastQueue();
        <span class="keyword">this</span>.finishedQueue = <span class="keyword">new</span> ToastQueue();
        <span class="keyword">this</span>.exec = Executors.newCachedThreadPool();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span></span>{
        exec.execute(<span class="keyword">new</span> Toaster(dryQueue));
        exec.execute(<span class="keyword">new</span> Butterer(dryQueue,butteredQueue));
        exec.execute(<span class="keyword">new</span> Jammer(butteredQueue,finishedQueue));
        exec.execute(<span class="keyword">new</span> Eater(finishedQueue));

    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        ToastOMatic matic = <span class="keyword">new</span> ToastOMatic();
        matic.begin();
        TimeUnit.SECONDS.sleep(<span class="number">5</span>);
        matic.exec.shutdownNow();
        System.out.println(matic.dryQueue.size());
        System.out.println(matic.butteredQueue.size());
        System.out.println(matic.finishedQueue.size());
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Toast</span> </span>{
    <span class="keyword">private</span> Status status = Status.DRY;
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;
    <span class="function"><span class="keyword">public</span> <span class="title">Toast</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{<span class="keyword">this</span>.id = id;}
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">butter</span><span class="params">()</span> </span>{<span class="keyword">this</span>.status = Status.BUTTERED;}
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jam</span><span class="params">()</span> </span>{<span class="keyword">this</span>.status = Status.JAMMED;}
    <span class="function"><span class="keyword">public</span> Status <span class="title">getStatus</span><span class="params">()</span> </span>{    <span class="keyword">return</span> <span class="keyword">this</span>.status;}
    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>{<span class="keyword">return</span> <span class="keyword">this</span>.id;}
    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{<span class="keyword">return</span> <span class="string">"Toast"</span> + id + <span class="string">":"</span> + status;}
}

<span class="class"><span class="keyword">class</span> <span class="title">ToastQueue</span> <span class="keyword">extends</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">Toast</span>&gt;</span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;
}

<span class="class"><span class="keyword">class</span> <span class="title">Toaster</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="keyword">private</span> ToastQueue toastQueue;
    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;
    <span class="function"><span class="keyword">public</span> <span class="title">Toaster</span><span class="params">(ToastQueue tq)</span></span>{
        <span class="keyword">this</span>.toastQueue = tq;
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span>{
            <span class="keyword">while</span>(!Thread.interrupted()){
                Toast t = <span class="keyword">new</span> Toast(count++);
                System.out.println(t);
                toastQueue.put(t);
                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);
            }
        }<span class="keyword">catch</span>(InterruptedException e){
            System.out.println(<span class="string">"Toaster Interrupted!"</span>);
        }
        System.out.println(<span class="string">"Toaster off!"</span>);
    }

}

<span class="class"><span class="keyword">class</span> <span class="title">Butterer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="keyword">private</span> ToastQueue dryQueue,butteredQueue;
    <span class="function"><span class="keyword">public</span> <span class="title">Butterer</span><span class="params">(ToastQueue dry,ToastQueue buttered)</span></span>{
        <span class="keyword">this</span>.dryQueue = dry;
        <span class="keyword">this</span>.butteredQueue = buttered;
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span>{
            <span class="keyword">while</span>(!Thread.interrupted()){
                Toast t = dryQueue.take();
                t.butter();
                System.out.println(t);
                butteredQueue.put(t);
                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);
            }
        }<span class="keyword">catch</span>(InterruptedException e){
            System.out.println(<span class="string">"Butterer Interrupted!"</span>);
        }
        System.out.println(<span class="string">"Butterer off!"</span>);
    }

}

<span class="class"><span class="keyword">class</span> <span class="title">Jammer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="keyword">private</span> ToastQueue butteredQueue,jammedQueue;
    <span class="function"><span class="keyword">public</span> <span class="title">Jammer</span><span class="params">(ToastQueue buttered,ToastQueue jammed)</span></span>{
        <span class="keyword">this</span>.butteredQueue = buttered;
        <span class="keyword">this</span>.jammedQueue = jammed;
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span>{
            <span class="keyword">while</span>(!Thread.interrupted()){
                Toast t = butteredQueue.take();
                t.jam();
                System.out.println(t);
                jammedQueue.put(t);
                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);
            }
        }<span class="keyword">catch</span>(InterruptedException e){
            System.out.println(<span class="string">"Jammer Interrupted!"</span>);
        }
        System.out.println(<span class="string">"Jammer off!"</span>);
    }

}

<span class="class"><span class="keyword">class</span> <span class="title">Eater</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="keyword">private</span> ToastQueue finishedQueue;
    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;
    <span class="function"><span class="keyword">public</span> <span class="title">Eater</span><span class="params">(ToastQueue finished)</span></span>{
        <span class="keyword">this</span>.finishedQueue = finished;
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span>{
            <span class="keyword">while</span>(!Thread.interrupted()){
                Toast t = finishedQueue.take();
                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);
                <span class="keyword">if</span>(t.getId() != counter++ || t.getStatus() != Status.JAMMED){
                    System.out.println(<span class="string">"ERROR:"</span> + t);
                    System.exit(<span class="number">1</span>);
                }<span class="keyword">else</span>{
                    System.out.println(<span class="string">"Comp!"</span> + t);
                }
            }
        }<span class="keyword">catch</span>(InterruptedException e){
            System.out.println(<span class="string">"Eater Interrupted!"</span>);
        }
        System.out.println(<span class="string">"Eater off!"</span>);
    }

}
</code></pre><p>线程协作是多线程编程的重要方面。截至目前的四篇都是并发编程的基础，实际的并发编程更为复杂，比如，上述提到的生产者消费者之间都是顺序的处理过程，而实际的场景更可能是部分并行进行，只有在关键路径才需要同步；同样的上述的场景中，每个阶段都只对应一个生产者或者一个消费者，可现实情况是一般的会有多个生产者同时进行生产，多个消费者同时进行消费。这种场景随处可见，只要是真实发生的工程都具有这样的属性。这些才是并发编程的核心点，接下来的几篇博客是并发编程的进阶内容，当然这些内容都是基于以上基础内容而来的。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/11/Java并发编程（三）-中断/">
                Java并发编程（三）-中断
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/11/Java并发编程（三）-中断/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/11/Java并发编程（三）-中断/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="中断">中断</h2><p>线程有四种状态：<strong>新建</strong>，<strong>就绪</strong>，<strong>阻塞</strong>，<strong>死亡</strong>，一个线程在以下四种情况下可以进入阻塞状态：</p>
<p>1.调用sleep()进入休眠<br>2.调用wait()进行挂起<br>3.等待IO<br>4.调用同步控制块，但不可获得锁。</p>
<p>在线程上调用interrupt()时，中断发生的唯一时刻就是任务要进入阻塞操作中，或者已经在阻塞操作内部时。如果这时调用interrupt()就会抛出InterruptedException.异常。如果只能通过依赖抛出异常而退出run()方法的话，我们并不能总是成功离开run()方法，因为如果此时碰巧run()没有产生阻塞，就不会抛出异常，也就不会退出run().</p>
<p>那么就需要第二种退出run()方法的方式，这种方式就是判断任务的中断状态，其状态可以通过interrupt()设置，然后通过调用interrupted()方法获取中断状态，interrupted()<strong>不仅会获取中断状态，还会清除中断状态</strong>（将其复位为false）。Thread.interrupted()提供了不抛出异常而离开run()的方式。下面分别是依赖线程当前已经阻塞并抛出异常来退出run()方法的例子和不依赖当前线程是否阻塞和是否抛出异常来退出run()方法的例子。</p>
<pre><code><span class="keyword">import</span> java.util.concurrent.TimeUnit;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminateTest</span> </span>{
    <span class="comment">//通过interrupted()退出run()方法</span>
    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="keyword">while</span>(!Thread.interrupted())
                System.out.println(<span class="string">"MyRunnable1 RUNNING..."</span>);
            System.out.println(<span class="string">" MyRunnable1 RUN FINISHED.."</span>);
        }
    }
    <span class="comment">//通过阻塞时通过使其抛出异常退出run()方法</span>
    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="keyword">while</span>(<span class="keyword">true</span>){
                System.out.println(<span class="string">"MyRunnable2 RUNNING..."</span>);
                <span class="keyword">try</span> {
                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);
                } <span class="keyword">catch</span> (InterruptedException e) {
                    System.out.println(<span class="string">"MyRunnable2 RUN FINISHED.."</span>);
                    <span class="keyword">break</span>;
                }
            }
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable1());
        t1.start();
        t1.interrupt();
        System.out.println(<span class="string">"T1.ISINTERRUPTED:"</span>+ t1.isInterrupted());

        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable2());
        t2.start();
        t2.interrupt();
        System.out.println(<span class="string">"T2.ISINTERRUPTED:"</span>+ t2.isInterrupted());
    }
}
</code></pre><p>需要说明的是interrupted()方法会清除中断状态使其复位,而isInterrupted()方法只判断当前中断状态，并不复位状态。其实isInterrupted()是调用了本地方法isInterrupted(boolean ClearInterrupted)并传了参数为false。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/11/深入理解内部类（四）/">
                深入理解内部类（四）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-11
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/11/深入理解内部类（四）/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/11/深入理解内部类（四）/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>这是深入理解内部类系列的最后一篇博客了，这篇博客介绍的功能并不常用，但是确是为内部类的完备性而设计的。</p>
<h2 id="内部类的继承">内部类的继承</h2><p>所谓内部类的继承就是指继承自一个内部类，继承类的构造器不能使用默认的构造器，因为其继承的内部类没法捕获对应的外部类对象，但是也不能简单的为继承类的构造器传递一个内部类对应外部类对象的引用，而必须使用特殊的语法：<code>enclosingClassReference.super()</code>。示例代码如下：</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> {</span>
    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> {</span>
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">WithInner</span>.<span class="title">Inner</span> {</span>
    <span class="comment">/*public InheritInner(){
        // doesnt work
    }*/</span>
    <span class="comment">/*public InheritInner(WithInner withInner){
    // doesnt work
    }*/</span>
    public <span class="type">InheritInner</span>(<span class="type">WithInner</span> withInner) {
        withInner.<span class="keyword">super</span>();<span class="comment">//right</span>
    }
}
</code></pre><h2 id="内部类是否可以被覆盖">内部类是否可以被覆盖</h2><p>内部类是可以被覆盖的，但是这里的覆盖是必须显示的继承，而不能像方法覆盖那样，如果子类有同名方法就默认覆盖父类方法。例如下面的代码输出结果是<code>OuterClass1.InnerClass</code> 而不是<code>OuterClass2.InnerClass.</code>这是因为每个内部类其实都是一个独立的个体，而不隶属于其外部类。</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">InheritInnerClass</span> {</span>

    public static void main(<span class="type">String</span>[] args) {
        <span class="type">OuterClass1</span> c2 = <span class="keyword">new</span> <span class="type">OuterClass2</span>();
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">OuterClass1</span> {</span>
    public <span class="type">OuterClass1</span>() {
        <span class="keyword">new</span> <span class="type">InnerClass</span>();
    }
    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> {</span>
        public <span class="type">InnerClass</span>() {
            <span class="type">System</span>.out.println(<span class="string">"OuterClass1.InnerClass"</span>);
        }
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">OuterClass2</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">OuterClass1</span> {</span>
    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">OuterClass1</span>.<span class="title">InnerClass</span>{</span>
        public <span class="type">InnerClass</span>() {
            <span class="type">System</span>.out.println(<span class="string">"OuterClass2.InnerClass"</span>);
        }
    }
}
</code></pre><h2 id="局部内部类">局部内部类</h2><p>局部内部类和匿名内部类实现的功能一致，但是局部内部类可以重载构造器并创建不止一个该内部类的对象。</p>
<h2 id="内部类标识符">内部类标识符</h2><p>内部类命名规则是如果内部类有名字，则其<code>.class</code>文件为<code>OuterClassName$InnerClassName.class</code><br>否则，如果是匿名内部类，则命名规则为<code>OuterClassName$1.class、OuterClassName$2.class</code>等。</p>
<h2 id="总结">总结</h2><p>内部类和接口一样重要，但往往我们更多的时候会注重使用接口而忽略了内部类的掌握，使用内部类还是接口这一般是设计阶段需要考虑的事情，但是我们应该重视内部类的合理使用。</p>
<p>最后，需要说明的是：本系列基于Java编程思想全书的章节设计安排和整理。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/08/深入理解内部类（三）/">
                深入理解内部类（三）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-08
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/08/深入理解内部类（三）/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/08/深入理解内部类（三）/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="内部类的作用">内部类的作用</h2><p>以上我们已经谈论了很多内部类的知识，但是这些知识都只是语法和语义层面的，但是内部类真正的作用是什么呢？我们知道内部类可以操作其外部类的成员，也就是说内部类是进入外部类的一个窗口。</p>
<p>如果只是通过内部类实现一个接口，那么其实这完全可以通过让外部类去实现就可以完成，确实，这样没错，如果只是实现一个接口外部类就可以满足，但是事实并不总是这样的，我们知道Java是单继承的，如果要继承多个(接口的)实现外部类就无能为力了，而内部类有效的实现了<strong>多重继承</strong>。每一个内部类都可以独立的继承一个实现，而不论其外部类是否继承了某个实现。</p>
<p>记住，内部类是一个独立的个体，同时外部类的每个内部类都可以以不同的方式实现同一个接口或继承同一个类，这样多重继承的场景就得到了完善。</p>
<h3 id="闭包与回调">闭包与回调</h3><p>闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义可以看出内部类是面向对象的闭包。</p>
<p>通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。<br>例如如下的代码：</p>
<p>首先定义一个接口 Incrementable，有一个方法 increment()</p>
<pre><code><span class="keyword">interface</span> <span class="title">Incrementable</span>{
    <span class="function"><span class="keyword">void</span> <span class="title">increment</span>(<span class="params"></span>)</span>;
}
</code></pre><p>然后定义一个类MyIncrement，其与接口有相同的方法increment();</p>
<pre><code><span class="keyword">class</span> <span class="title">MyIncrement</span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span>(<span class="params"></span>)</span>{
        System.<span class="keyword">out</span>.println(<span class="string">"MyIncrement"</span>);
    }
}
</code></pre><p>之后再定义一个Callee类，其继承自 MyIncrement，我们看到其覆写了MyIncrement的increment()方法,如果直接再实现接口我们就不知道覆写的这个increment()到底是实现Incrementable接口的实现还是覆写MyIncrement，因此我们通过一个内部类Closure 实现这个Incrementable接口并实现其对应的increment()方法，这个increment()是一个回调方法，以提供返回Callee的钩子(hook),而且很安全，因为任何人获得这个引用，都只能调用increment()方法，通过Callee.this.increment()回调了Callee类。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Callee</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span></span>{
    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.increment();
        System.out.println(i++);
    }
    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>{
            Callee.<span class="keyword">this</span>.increment();
        }
    }
    <span class="function"><span class="keyword">public</span> Incrementable <span class="title">getCallbackReference</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Closure();
    }
}
</code></pre><p>最后，我们定义一个Caller类，其构造函数需要一个Incrementable引用，之后任意时刻都可以通过此引用回调Callee类。这充分体现了回调的灵活性。</p>
<pre><code><span class="keyword">class</span> <span class="title">Caller</span>{
    <span class="keyword">private</span> Incrementable callbackReference;
    <span class="function"><span class="keyword">public</span> <span class="title">Caller</span>(<span class="params">Incrementable cbh</span>)</span>{
        callbackReference = cbh;
    }
    <span class="function"><span class="keyword">void</span> <span class="title">go</span>(<span class="params"></span>)</span>{
        callbackReference.increment();
    }
}
</code></pre><p>我们写一个测试类进行下测试，代码如下，我们调用了两次cee.increment()，使Callee的变量i增加为2，然后我们通过cer.go()回调Callee，从输出结果看，我们回调到了Callee。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CallBackTest</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        Callee cee = <span class="keyword">new</span> Callee();
        Caller cer = <span class="keyword">new</span> Caller(cee.getCallbackReference());
        cee.increment();
        cee.increment();
        cer.go();
    }
}
</code></pre><h3 id="内部类与控制框架">内部类与控制框架</h3><p>控制框架是一类特殊的应用程序框架，用来解决响应事件的需求，主要用来响应事件的系统被称为事件驱动的系统。Java中典型的事件驱动系统就是GUI。</p>
<p>假设有这样一个控制框架，其工作就是在事件“就绪”的时候执行事件，对于如何执行和控制什么，控制框架并不包含任何具体信息，这些动作都由对应的action()动作完成，这个action是通过继承来提供的，而这里的继承是通过内部类实现的。</p>
<p>下面的抽象类描述了要控制的事件的开始时间，是否就绪，以及一个抽象的action()动作</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>{
    <span class="keyword">private</span> <span class="keyword">long</span> eventTime;
    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">long</span> delayTime;
    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(<span class="keyword">long</span> delayTime)</span></span>{
        <span class="keyword">this</span>.delayTime = delayTime;
        start();
    }
    <span class="comment">/*
     * 可以随时重新设置启动计时器
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>{
        eventTime = System.nanoTime() + delayTime;
    }
    <span class="comment">/*
     * 表示何时可以运行action()方法。
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span></span>{
        <span class="keyword">return</span> System.nanoTime() &gt;= eventTime;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;
}
</code></pre><p>接下来是一个用来管理和触发事件的实际的<strong>控制框架</strong>。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Controller</span> {
    <span class="keyword">private</span> List&lt;Event&gt; eventList = <span class="keyword">new</span> ArrayList&lt;Event&gt;();
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEvent</span>(<span class="params">Event e</span>)</span>{
        eventList.add(e);
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>{
        <span class="keyword">while</span>(eventList.size() &gt;<span class="number">0</span>){
            <span class="keyword">for</span>(Event e: <span class="keyword">new</span> ArrayList&lt;Event&gt;(eventList)){
                <span class="keyword">if</span>(e.ready()){
                    System.<span class="keyword">out</span>.println(e);
                    e.action();
                    eventList.remove(e);
                }
            }
        }
    }
}
</code></pre><p>控制框架循环遍历eventList,寻找就绪的(ready())的事件（event）然后运行它(action())并移除。<br>这里我们其实并不知道Event到底做了什么，怎么做，这正式这个设计的关键所在：<strong>使变化的事务与不变的事务相互分离</strong>，这里不变的就是我们要铜鼓控制框架执行这些Event，而变化的就是这些不同的Event所执行的具体动作。这些正是内部类要做的事情：<br>1、控制框架是由单个类创建的，从而使得实现的细节被封装起来，内部类用来表示解决问题锁必须的各种action()的不同实现。<br>2、内部类可以很容易的访问外部类（这里就是Event）成员，从而可以使这种实现变得简单。</p>
<p>下面是该控制框架的一个特定实现GreenhouseControls：温控室的控制（控制灯光、水、温度及响铃和重启系统等），温控室的各种控制（Event）是非常不同的，但是控制框架的设计使得分离这些不同的代码非常容易。可以在单一的类里产生对同一个基类Event的多种不同实现。</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">GreenhouseControls</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Controller</span> {</span>
    <span class="keyword">private</span> boolean light = <span class="literal">false</span>; <span class="comment">//这里只light演示灯光、温度调节器的控制</span>
    public <span class="class"><span class="keyword">class</span> <span class="title">LightOn</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">LightOn</span>(long delayTime){
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            light = <span class="literal">true</span>;
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Light is on"</span>;
        }
    }
    public <span class="class"><span class="keyword">class</span> <span class="title">LightOff</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">LightOff</span>(long delayTime){
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            light = <span class="literal">false</span>;
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Light is off"</span>;
        }
    }

    <span class="keyword">private</span> <span class="type">String</span> thermostat = <span class="string">"Day"</span>;
    public <span class="class"><span class="keyword">class</span> <span class="title">ThermostatDay</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">ThermostatDay</span>(long delayTime){
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            thermostat = <span class="string">"Day"</span>;
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Thermostat on day setting"</span>;
        }
    }
    public <span class="class"><span class="keyword">class</span> <span class="title">ThermostatNight</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">ThermostatNight</span>(long delayTime){
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            thermostat = <span class="string">"Night"</span>;
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Thermostat on night setting"</span>;
        }
    }

    public <span class="class"><span class="keyword">class</span> <span class="title">Bell</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">Bell</span>(long delayTime){
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            addEvent(<span class="keyword">new</span> <span class="type">Bell</span>(delayTime));
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Bing"</span>;
        }
    }

    public <span class="class"><span class="keyword">class</span> <span class="title">Restart</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        <span class="keyword">private</span> <span class="type">Event</span>[] eventList;
        public <span class="type">Restart</span>(long delayTime,<span class="type">Event</span>[] eventList){
            <span class="keyword">super</span>(delayTime);
            <span class="keyword">this</span>.eventList = eventList;
            <span class="keyword">for</span>(<span class="type">Event</span> e: eventList){
                addEvent(e);
            }
        }
        <span class="annotation">@Override</span>
        public void action() {
            <span class="keyword">for</span>(<span class="type">Event</span> e: eventList){
                e.start();
                addEvent(e);
            }
            start();
            addEvent(<span class="keyword">this</span>);
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Restarting system"</span>;
        }
    }

    public static <span class="class"><span class="keyword">class</span> <span class="title">Terminate</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">Terminate</span>(long delayTime) {
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            <span class="type">System</span>.exit(<span class="number">0</span>);
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Terminating system"</span>;
        }
    }
}
</code></pre><p>Light 和 Thermostat 控制比较好理解，Bell控制响铃，然后在事件列表上增加一个Bell对象，于是过一段时间后可以再次响铃。而Restart控制系统重启，一个由Event对象组成的数组被递交给Restart，该数组被加到控制器上，由于Restart本身也是一个Event所以同样可以加到Restart.action()中，以使系统有规律的重新启动自己。</p>
<p>下面的类通过创建GreenhouseControls对象，并添加各种不同的Event对象来配置该系统：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenhouseController</span> </span>{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        GreenhouseControls gc = <span class="keyword">new</span> GreenhouseControls();
        gc.addEvent(gc.<span class="keyword">new</span> Bell(<span class="number">1000</span>));
        Event[] eventList = { gc.<span class="keyword">new</span> LightOn(<span class="number">200</span>), gc.<span class="keyword">new</span> LightOff(<span class="number">400</span>),
                gc.<span class="keyword">new</span> ThermostatNight(<span class="number">0</span>), gc.<span class="keyword">new</span> ThermostatDay(<span class="number">600</span>) };
        gc.addEvent(gc.<span class="keyword">new</span> Restart(<span class="number">2000</span>, eventList));
        gc.addEvent(<span class="keyword">new</span> GreenhouseControls.Terminate(<span class="number">1000000</span>));
        gc.run();
    }
}
</code></pre><p>这个类初始化系统，所以添加了所有响应的事件，Restart事件反复运行，且它每次都会将EventList加载到GreenhouseControls对象中。我们这时就会发现内部类的强大了，特别是在控制框架中，例如在Java GUI中内部类的作用就体现的非常充分。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/07/深入理解内部类（二）/">
                深入理解内部类（二）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-07
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/07/深入理解内部类（二）/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/07/深入理解内部类（二）/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="内部类向上转型">内部类向上转型</h2><p>内部类可以向上转型为其基类或其实现的接口，这个时候内部类就有了较大的用武之地，因为内部类作为某个接口的实现能够完全不可见并且不可用，外围所得到的只是基类或实现接口的引用，因此可以非常方便的隐藏实现细节，例如对应一个private的内部类，给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，完全隐藏实现细节，对于外部调用者，由于不能访问实现类任何新增的，原本不属于公共接口的方法，所以扩展接口是没有意义也是不可能的，这样给Java编译器提供了生产更高效代码的条件，同时也更好的保护了实现类的内部细节。例如如下代码：<br>我们首先定义一个公共接口Course，该接口返回一个课程名。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Course</span> {
    <span class="function">String <span class="title">getCourseName</span>(<span class="params"></span>)</span>;
}
</code></pre><p>然后我们定义一个CourseImpl类，其内部类CourseInnerImpl真正实现Course接口：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="function"><span class="keyword">public</span> CourseInnerImpl <span class="title">getCourseInnerImpl</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> CourseInnerImpl();
    }
    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseInnerImpl</span> <span class="keyword">implements</span> <span class="title">Course</span></span>{
        String coursePref = <span class="string">"CS:"</span>;
        String[] course ={<span class="string">"C++"</span>,<span class="string">"Java"</span>};
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> coursePref +course[Math.abs(r.nextInt()%<span class="number">2</span>)];
        }
    }
}
</code></pre><p>最后我们在第三个类TestCourse里访问Course接口的功能：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestCourse</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        CourseImpl ci = <span class="keyword">new</span> CourseImpl();
        Course c = ci.getCourseInnerImpl();
        <span class="comment">//CourseInnerImpl = c2 = ci.getCourseInnerImpl(); 错误</span>
        System.<span class="keyword">out</span>.println(c.getCourseName());
        System.<span class="keyword">out</span>.println(c.getCourseName());
        System.<span class="keyword">out</span>.println(c.getCourseName());
    }
}
</code></pre><p>可以看到我们只能获取到内部类向上转型后的公共接口Course类型，而不能访问到其具体实现CourseInnerImpl类型，即使getCourseInnerImpl()返回的类型是CourseInnerImpl，这样内部类就做到了实现细节的隐藏，外部只需要并只能关注公共接口提供的信息而不能访问内部类的细节。</p>
<h2 id="在方法和作用域内的内部类-局部内部类">在方法和作用域内的内部类-局部内部类</h2><p>到目前为止我们探讨的内部类都是定义在类作用域内的内部类，其实内部类的用法远不止如此，我们可以在方法内或者任何作用域内定义内部类，这样的内部类称为局部内部类。</p>
<p>例如，我们可以把上面的CourseImpl类改写成如下方式，CourseInnerImpl类在方法getCourseInnerImpl内，作为一个局部内部类存在，这样，不仅其他类不能访问该内部类，就是类自身除了方法getCourseInnerImpl外都不能访问内部类的具体实现了。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="function"><span class="keyword">public</span> Course <span class="title">getCourseInnerImpl</span><span class="params">()</span></span>{
        <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseInnerImpl</span> <span class="keyword">implements</span> <span class="title">Course</span></span>{
            String coursePref = <span class="string">"CS:"</span>;
            String[] course ={<span class="string">"C++"</span>,<span class="string">"Java"</span>};
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>{
                <span class="keyword">return</span> coursePref +course[Math.abs(r.nextInt()%<span class="number">2</span>)];
            }
        }
        <span class="keyword">return</span> <span class="keyword">new</span> CourseInnerImpl();
    }
}
</code></pre><p>我们也可以改写为让内部类在方法的某个作用域内，例如：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="function"><span class="keyword">public</span> Course <span class="title">getCourseInnerImpl</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>{
        <span class="keyword">if</span>(flag){
            <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseInnerImpl</span> <span class="keyword">implements</span> <span class="title">Course</span></span>{
                String coursePref = <span class="string">"CS:"</span>;
                String[] course ={<span class="string">"C++"</span>,<span class="string">"Java"</span>};
                <span class="annotation">@Override</span>
                <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>{
                    <span class="keyword">return</span> coursePref +course[Math.abs(r.nextInt()%<span class="number">2</span>)];
                }
            }
            <span class="keyword">return</span> <span class="keyword">new</span> CourseInnerImpl();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</code></pre><p>这并不是说只有满足条件才会创建这个内部类，它其实和其他类一样已经编译了，但是在定义该内部类的作用域之外它是不可用的，除此之外与其他普通类没有任何区别。</p>
<h2 id="匿名内部类">匿名内部类</h2><p>匿名内部类就是没有名字的内部类，比如如下代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="function"><span class="keyword">public</span> Course <span class="title">getCourseInnerImpl</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Course(){
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>{
                <span class="keyword">return</span> <span class="string">"CLASS NAME"</span>;
            }
        };
    }
}
</code></pre><p>其中的</p>
<pre><code><span class="keyword">return</span> <span class="keyword">new</span> Course(){
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">String <span class="title">getCourseName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"CLASS NAME"</span>;
    }
}
</code></pre><p>就是创建了一个实现了Course接口的匿名内部类，其等价于上面提到的在方法内实现的内部类，<code>new</code>表达式返回的引用自动向上转型为Course类型。如果基类需要有参数的构造器，对于匿名内部类，我们同样可以实现：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="keyword">public</span> <span class="function">Course <span class="title">getCourseInnerImpl</span><span class="params">(String name)</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> MyCourse(name){
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="function">String <span class="title">getCourseName</span><span class="params">()</span> </span>{
                <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">getName</span><span class="params">()</span></span>;
            }
        };
    }
}
</code></pre><p>其中MyCourse是Course接口的一个实现，其有一个参数，这里直接将参数传递给new MyCourse（String name）即可。如果直接使用<code>return name</code>是不行的会导致编译错误，此时我们必须保证传入的参数是final的才可以。之所以我们这里用到<code>return super.getName()</code>进行返回可以，是因为在匿名内部类中不直接用到name。<br>例如：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="function"><span class="keyword">public</span> Course <span class="title">getCourseInnerImpl</span><span class="params">(<span class="keyword">final</span> String name)</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> MyCourse(name){
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>{
                <span class="keyword">return</span> name;
            }
        };
    }
} 
</code></pre><p>内部类虽然可以扩展类，也可以实现接口，但是并不能两者兼备，而且实现接口的时候也只能实现一个接口，同样，由于没有名字，在匿名内部类中不可能有命名构造器，只能通过实例初始化方式达到构造器的效果，但是由于不能重载实例初始化方法，所以匿名内部类也只有一个“构造器”。</p>
<h2 id="嵌套类">嵌套类</h2><p>嵌套类一般的指静态内部类，即static class，静态内部类和普通类有以下不同：<br>1、创建静态内部类对象时，不需要其外部类的对象<br>2、不能从静态内部类的对象中访问非静态的外部类对象<br>3、静态内部类可以有static字段和数据，而普通内部类不可以。</p>
<p>另外嵌套类还有如下表示形式，可以看到不管嵌套多少层，内部类都可以透明的访问其所有外部类的成员，并且内部类的创建也会自然的自动根据其直接外部类创建。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;
    <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span>{
        <span class="keyword">private</span> <span class="keyword">int</span> b = a + <span class="number">1</span>;
        <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span></span>{
            <span class="keyword">private</span> <span class="keyword">int</span> c = a + b + <span class="number">1</span>;
            <span class="class"><span class="keyword">class</span> <span class="title">ClassD</span></span>{
                <span class="keyword">private</span> <span class="keyword">int</span> d = a + b + c +<span class="number">1</span>;
            }
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args){
        ClassA a = <span class="keyword">new</span> ClassA();
        ClassA.ClassB b = a.<span class="keyword">new</span> ClassB();
        ClassA.ClassB.ClassC c = b.<span class="keyword">new</span> ClassC();
        ClassA.ClassB.ClassC.ClassD d= c.<span class="keyword">new</span> ClassD();
    }
}
</code></pre>
        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/07/Java并发编程（二）-共享资源/">
                Java并发编程（二）-共享资源
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-07
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/07/Java并发编程（二）-共享资源/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/07/Java并发编程（二）-共享资源/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>这篇简单介绍线程资源共享即同步问题。</p>
<p>多线程各自运行，你就无法确定一个线程何时在运行，当前哪个线程在运行。这在对<strong>临界资源</strong>访问时就肯定会出现问题，假设如果两个线程试图同时获取一个相同的资源的时候，如果不加以控制，就可能至少有其中一个线程访问到状态不正确的资源，因此使用线程时一个重要的工作就是进行线程的同步。基本上并发模式在解决线程冲突问题的时候基本上都是采用序列化访问共享资源的方案，不同的场景有具体的不同处理方式。</p>
<h2 id="1-Synchronized_&amp;_Lock">1.Synchronized &amp; Lock</h2><p>Java中通过synchronized 关键字为资源冲突提供了内置支持，当任务要执行被synchronized 保护的代码时，会<strong>先检查锁是否可用，之后获取锁，然后执行代码，最后释放锁</strong>。<br>所有的共享资源一般是以对象的形式存在内存片段中，但也可以是文件，IO端口，打印机等。要控制对共享资源的访问，先要将其包装进一个对象，然后把所有要访问这个资源的方法标记为synchronized。如<strong>果某个任务处于对标记为synchronized 的方法的调用中，那么在这个任务从该方法返回前，其他所有要调用该被标记为synchronized 的方法的任务都会被阻塞</strong>。<br>所有对象都自动含有单一的锁，当<strong>一个任务</strong>在对象上调用其任意的synchronized 方法时，此对象都被加锁。这时<strong>其他任何任务</strong>要调用该对象上其他的synchronized 方法只有等到前一个synchronized 方法调用完毕并释放了锁之后才能被调用。<br>一个任务可以多次获得对象的锁，如果该任务已经获得当前对象的锁，那么它在调用了该对象的synchronized 方法后，如果该方法需要继续调用对象的另一个synchronized 方法是可以的，JVM负责跟踪和维护对象被加锁的次数，如果对象被第一次加锁，则计数器为1，下一次加锁计数器为2，直到完全释放，计数器变为0，此时其他任务就可以调用对象的synchronized 方法了，但是在计数器不为0的时候，只有当前已经获取到锁的任务可以调用对象的synchronized 方法。<br>针对每一个类，也有一个锁 。synchronized static 可以保证在类的范围内防止对static数据的并发访问。<br>如果在类中有超过一个方法在处理临界资源，那必须同步所有处理这些资源的相关方法，否则并发就不能正常工作。<br> 除了使用synchronized 之外，还可以使用Lock进行显示的加锁操作，显示的加锁比synchronized 更灵活，具有更细粒度的操作，可以在锁失败时可以做一些清理工作，显示的锁操作必须使用try catch finally语句，并且数据返回必须在try语句块中，以确保unlock()不会过早发声，将数据暴露给其他任务，而且必须有finally语句块，在其中处理unlock()操作。显示的加锁操作比synchronized赋予了更灵活的特性，但是维护起来比synchronized 跟复杂，代码也更更容易出错，但是由于显示加锁允许做更多的控制，因此适用范围更广。</p>
<h2 id="2-Volatile">2.Volatile</h2><p>在Java中<strong>不能依赖原子性就不使用同步</strong>，volatile关键字修饰属性主要是为了<strong>保证可视性但不保证互斥</strong>，因为一般情况下，线程对域的修改即使是不中断的原子操作，对其他任务也可能是不可见的，因为此时的修改可能只是暂时性的存储在线程的本地处理器的缓存中（不强制必须刷到主存中），不同任务对应用有不同的视图，volatile 保证了如果一个域一旦发生了写操作，就强制将修改立即写入主存中，这样就保证了修改的可视性。<br>当一个域的值依赖于它之前的值或者一个域的值依赖其他域的值，那么volatile就无法正常工作了，使用volatile而不是使用synchronized唯一安全的情况是类中只有一个可变的域。第一选择是使用synchronized而不是有风险的volatile。同一个变量线程之间的可见性和线程中相互操作的互斥性是两件事情。操作互斥是提供了操作整体的原子性，千万不能混淆。</p>
<h2 id="3-Atomic">3.Atomic</h2><p>在concurrent包中，实现了多个特殊的元自行变量类型，对这些类型使用原子性操作不需要使用synchronized等同步机制而可以保证正确性。Atomic类型性能比使用同步更好，JDK是通过JNI的方式使用了硬件支持的CAS指令，一般的我们更倾向于使用synchronized或者Lock等方式，而避免可能的安全性问题，除非有特别的性能要求。</p>
<h2 id="4-临界区">4.临界区</h2><p>有时候，你并不需要对整个方法进行同步，而只需要对方法中的部分临界资源进行同步，通过这种方式分离出来的代码段被称为临界区，它也可以使用synchronized建立，此时需要在synchronized中指定一个对象，表示此对象的锁被用来对括号内的代码进行同步控制，这段代码就称为临界区，也即同步控制块，在进入这段代码前必须获取同步对象的锁，否则只能等待，通过使用同步控制块而不是使用整个方法的同步控制。可以使多个任务访问对象的时间性能得到显著提高。<br>synchronized块一般的用法是在当前对象上加锁，即synchronized(this)，此时其他任务就不能对该对象的所有其他synchronized进行调用了。但是如果当前对象的不同的synchronized 块加锁的对象是不一样的，则加锁对象不一样的同步控制块彼此不是互斥的，也即一个任务在访问该对象的synchronized(Object1)同步控制块时，另一个任务也可以同时访问该对象的另一个同步控制块synchronized(Obeject2).<br>如果需要对一个非线程安全的类进行线程安全的操作，我们可以创建一个该类的Manager类，通过在该Manager类中的同步方法访问该类从而实现非线程安全的类的线程安全的访问。 </p>
<h2 id="5-线程本地存储">5.线程本地存储</h2><p>为了对每个线程都创建变量的本地存储，可以使用concurrent.ThreadLocal类，这样每个线程都会创建自己线程的本地存储变量，线程之间不共享该变量，也就不需要同步控制了。例如：TreadLocal<integer> 。</integer></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/05/Java并发编程（一）-并发编程简介/">
                Java并发编程(一)-并发编程简介
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-05
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/05/Java并发编程（一）-并发编程简介/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/05/Java并发编程（一）-并发编程简介/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>Java中的并发就是指多线程编程，并发编程可以使我们将程序划分为多个分离的，独立运行的任务。每一个任务都由执行线程来驱动。线程用于驱动任务，因此需要一种描述任务的方式，在Java中由Runnable接口来提供。要想定义一个基于线程驱动的任务，只需要实现Runnable接口，并编写其run()方法，在其中实现你的任务需要实现的功能。<br>任务的run()方法通常来讲总是以某种形式的循环实现，这样这个任务就可以一直执行下去，直到满足一定的条件不再需要执行为止，这个满足一定条件就是跳出循环的条件。这里的Runnable 和run()方法不具备执行的能力，它必须显示的依附于一个线程上，因此叫做线程驱动任务。</p>
<h2 id="1-Thread类">1.Thread类</h2><p>Thread类是Java并发最基础也是最核心的线程类，最基本的要让一个Runnable接口转变成一个可执行的任务就是将其提交给一个Thread对象，然后调用Thread对象的start()方法使其运行，此时线程就会自动驱动Runnable任务并执行其run()方法。</p>
<pre><code><span class="keyword">Thread</span> t <span class="subst">=</span> <span class="literal">new</span> <span class="keyword">Thread</span>(<span class="literal">new</span> 一个Runnable对象)
t<span class="built_in">.</span>start();
</code></pre><p>这里用Runnable接口构建了一个Thread对象，并且这个Thread对象通过调用其start()方法对Runnable的run()方法进行调用，之后run()就可以执行一系列的动作了，start()方法在调用了run()方法后会很快返回，然后主线程（调用start方法的线程）可以继续执行接下来的动作。而于此同时也产生了一个新线程，它就是执行run()的线程，这两个线程在这种情况下没有任何同步，完全是随操作系统和JDK的调用执行自己的任务。</p>
<p>例如下面的程序就是main线程驱动了一个新的线程，然后这两个线程根据操作系统和JDK的调用执行，直到flag标志变为false时MyRunnable才从run()方法反回。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExecuteRunnable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;
    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="comment">//直到flag为false才停止执行</span>
            <span class="keyword">while</span>(flag == <span class="keyword">true</span>){
                System.out.println(<span class="string">"I'm MyRunnable tread!"</span>);
            }
        }
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="comment">// <span class="doctag">TODO</span> Auto-generated method stub</span>
        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());
        t.start();
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)
            System.out.println(<span class="string">"I'm MAIN thread!"</span>);
        flag = <span class="keyword">false</span>;
    }
}
</code></pre><p>需要说明的是，如果在main线程的最后没有对flag进行置false操作，MyRunnable就会一直执行无限执行下去。main()方法创建了Thread t之后并没有捕获任何对其的引用，而我们知道Java的垃圾回收机制会对没用引用的死对象就行回收，但是这里的线程t不仅没被及时回收，而且在main结束之后还会一直执行下去，这是因为虽然main没有捕获Thread t的引用，但是每个线程都会进行自我注册，因此实际上有一个对其的引用，直到其从run()返回。</p>
<h2 id="2-Executor">2.Executor</h2><p>如上我们通过显示的创建一个Thread对象来驱动一个具体的任务，然而在Java的并发模型中提供了一个更好的实现方式Executor，其为我们管理Thread对象，简化并发编程，它在客户端和任务之间提供了一个间接层，不用客户显示的执行任务，任务由它去执行并管理，而无需显示的管理线程的生命周期。Executor 知道如何恰当的构建上下文来执行Runnable对象，我们通过Executors类的静态方法创建不同类型的Executor.</p>
<pre><code>ExecutorService <span class="keyword">exec</span> = Exectors.newCachedThreadPool();
<span class="keyword">exec</span>.executor(new 一个Runnable对象);
<span class="keyword">exec</span>.<span class="keyword">shutdown</span>();
</code></pre><p>这里的单个exec可以被用来创建和管理系统中所有的任务，这里的exec类型为每一个提交给它的任务都通过调用executor创建一个新的线程执行，最后调用shutdown()方法是为了防止有新的任务被提交给这个exec对象。</p>
<pre><code><span class="keyword">package</span> examples.concurrent.java;
<span class="keyword">import</span> java.util.concurrent.ExecutorService;
<span class="keyword">import</span> java.util.concurrent.Executors;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExecuteRunnable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;
    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="keyword">int</span> id;
        <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> id)</span></span>{
            <span class="keyword">this</span>.id = id;
        }
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="comment">//直到flag为false才停止执行</span>
            <span class="keyword">while</span>(flag == <span class="keyword">true</span>){
                System.out.println(<span class="string">"I'm MyRunnable tread-"</span> + id);
                Thread.yield();
            }
            System.out.println(<span class="string">"I'm Returned tread-"</span> + id);
        }
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="comment">// <span class="doctag">TODO</span> Auto-generated method stub</span>
        ExecutorService exec = Executors.newCachedThreadPool();
        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++){
            exec.execute(<span class="keyword">new</span> MyRunnable(i));
        }
        exec.shutdown();<span class="comment">//如果注释掉这句话，程序将一直执行并等待。</span>
        System.out.println(<span class="string">"I'm MAIN thread!"</span>);
        flag = <span class="keyword">false</span>;
    }
}
</code></pre><p>从上面的代码中可以看到，我们没有显示的创建驱动任务的Thread而是通过Executor管理并执行了多个线程，同时注意如果没有调用exec.shutdown()，程序会一直运行并等待新的任务的提交，因此当我们明确没有任务要执行的时候就需要调用shutdown将其Executor服务关掉。</p>
<p>通常我们首选的Executor是CachedThreadPool,它会在程序执行过程中创建与所需数据相同的线程，并且在有旧线程被回收的时候停止创建新的线程，而如果这种方式可能出现问题的时候我们也可以选择使用FixedThreadPool,它将会创建固定数据的线程，可以预先创建创建对应数据的线程，不用每次为新来的任务创建对应的线程而产生创建线程的开销，一旦任务数多于对应的线程数，就会产生等待。另一种特殊的固定线程的是SingleThreadExecutor,顾名思义只创建一个线程，是线程数量为1的FixedThreadPool,这个执行器可以隐式的使任务根据其提交的先后顺序进行排队，即序列化任务。</p>
<h2 id="3-Callable">3.Callable</h2><p>Runnable不返回值。如果需要返回值，则可以实现Callable接口，它有一个类型参数,并且对应的方法是call()，对应的调用方法是Executor.submit()。该调用返回一个Future对象，并使用call()返回的结果进行了参数化，例如call()返String类型，则返回的是Future<string>对象，通过Future对象的get()方法可以获取最终的返回值。</string></p>
<h2 id="4-休眠、优先级、让步、后台线程、JOIN">4.休眠、优先级、让步、后台线程、JOIN</h2><p><strong>休眠：</strong>通过TimeUnit对应的sleep()方法，其使当前线程休眠一段时间（阻塞），sleep()方法可以抛出InterruptedException，我们需要在本地（当前线程）处理这个异常，因为异常不能跨线程传播，我们需要明确的是不能依赖sleep函数去控制程序的顺序，必须使用同步控制。</p>
<p><strong>优先级：</strong>调度器倾向于让优先级高的线程先执行，但是优先级低的也仍然有机会执行，这并不会导致死锁。不同的操作系统对JDK优先级的映射也不同，一般情况下我们不应该对线程设置优先级，最多只使用MAX_PRIORITY NORM_PRIORITY MIN_PRIORITY三个级别。例如：Thread.currentThread().setPriority(MAX_PRIORITY).</p>
<p><strong>让步：</strong>通过调用Thread.yield()暗示当前线程可以让步，其他线程可以运行，但是这只是一种建议，类似于gc()一样，没有任何机制保障一定会让步，我们也不能依赖它。</p>
<p><strong>后台线程：</strong>所谓后台线程就是在程序运行的时候提供一种通用的服务的线程，并且这种线程不属于程序中不可或缺的部分，当所有的非后台线程结束时，后台线程会全部被杀死。如果非后台线程还在运行，程序就不会终止。后台线程必须在调用start()之前先调用setDaemon()方法才能设置为后台线程。需要说明的是：后台线程创建的任何线程都是后台线程，即使被创建的线程并没有声明为后台线程，后台线程会在非后台线程都结束的时候直接从run()方法返回，连最后的finally子句都不会执行，因此我们无法优雅的关掉后台线程。</p>
<p><strong>JOIN:</strong>一个线程可以在其他线程上调用join，而等待这个线程醒来，此时，当前线程将会挂起，而直到目标线程（也就是被在其上调用Join的线程）结束。当然对join的调用可以被interrupt()方法中断，因此需要用try catch语句，当一个线程在另一个线程上调用interrupt()时将给该线程设定一个标志，表明线程已经被中断，但是在异常捕获时将清除这个标志，所以在catch子句中，isInterrupted()标志总是为false。其实在JDK5之后的的concurrent包中有CyclicBarrier比join更好用。</p>
<h2 id="5-异常的捕获">5.异常的捕获</h2><p>请记住，一旦异常从线程的run()方法逃逸出来，它就会向外传送到控制台，不能用普通的异常处理机制try catch语句进行捕获，例如下面的线程总是会在run()中抛出一个异常，而在对应代码段加上try catch语句是无效的，仍旧会抛出对应的异常。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="keyword">try</span> {
            ExecutorService exec = Executors.newCachedThreadPool();
            exec.execute(<span class="keyword">new</span> ExceptionThread());
        } <span class="keyword">catch</span> (Exception e) {
        }
    }
｝
</code></pre><p>Thread.UncaughtExceptionhandler是JDK5中的一个新接口。它允许在每个Thread上都附着一个异常处理器，Thread.UncaughtExceptionhandler.uncaughtException()会在线程因未捕获异常而死亡时被调用。接下来我们的工作就是在用Executor产生线程时为每个线程对象都附着一个Thread.UncaughtExceptionhandler。<br>Executors创建线程除了可以使用无参的方法，还可以为方法传递一个ThreadFactory对象，而这里我们就是利用这个ThreadFactory对象为我们的线程附着Thread.UncaughtExceptionhandler。示例代码如下：</p>
<pre><code><span class="keyword">class</span> <span class="title">HandlerThreadFactory</span> <span class="title">implements</span> <span class="title">ThreadFactory</span>{

    @<span class="function">Override
    <span class="keyword">public</span> Thread <span class="title">newThread</span>(<span class="params">Runnable r</span>) </span>{
        System.<span class="keyword">out</span>.println(<span class="keyword">this</span> + <span class="string">"Create new Thread!"</span>);
        Thread t = <span class="keyword">new</span> Thread(r);
        System.<span class="keyword">out</span>.println(t);
        t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHander());
        System.<span class="keyword">out</span>.println(t.getUncaughtExceptionHandler());
        <span class="keyword">return</span> t;
    }
}
</code></pre><p>可以看到，实现ThreadFactory需要实现其中的newThread()方法，这里就是我们要创建的线程，我们的工厂类HandlerThreadFactory 就是在这里通过setUncaughtExceptionHandler()方法为我们的线程附着上默认的异常处理器。<br>可以看到我们创建了工厂，还需要创建对应的异常处理器，这里是MyUncaughtExceptionHander，其示例代码如下，它需要实现我们上面提到的Thread.UncaughtExceptionHandler接口并且实现其中的uncaughtException()方法，这个方法就是正式处理异常要调用的方法。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHander</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>{
        System.out.println(<span class="string">"Catch this:"</span> + e);
    }
}
</code></pre><p>这时，我们将我们的工厂传递给Executors对应的方法后，新创建的线程在run()中抛出的异常就会被捕获。完整代码如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThreadWithUncaughtExceptionHandler</span> </span>{
    <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHander</span> <span class="keyword">implements</span>         <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>{
            System.out.println(<span class="string">"Catch this:"</span> + e);
        }    
    }
    <span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>{
            System.out.println(<span class="keyword">this</span> + <span class="string">"Create new Thread!"</span>);
            Thread t = <span class="keyword">new</span> Thread(r);
            System.out.println(t);
            t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHander());
            System.out.println(t.getUncaughtExceptionHandler());
            <span class="keyword">return</span> t;
        }
    }
    <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            Thread t = Thread.currentThread();
            System.out.println(<span class="string">"run by :"</span> + t);
            System.out.println(<span class="string">"en:"</span> + t.getUncaughtExceptionHandler());
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();
        }    
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        ExceptionThreadWithUncaughtExceptionHandler it = <span class="keyword">new</span> ExceptionThreadWithUncaughtExceptionHandler();
        <span class="comment">//Thread.setDefaultUncaughtExceptionHandler(it.new MyUncaughtExceptionHander());</span>
        ExecutorService exec = Executors.newCachedThreadPool(it.new HandlerThreadFactory());
        exec.execute(it.new ExceptionThread2());
    }
}
</code></pre><p>我们可以根据需要为我们的线程逐个设置异常处理器，但是如果我们知道在代码中需要处处使用相同的异常处理器，那么我们可以在Thread类中设置一个静态阈来设置所有线程的默认异常处理器。其用法为：Thread.setDefaultUncaughtExceptionHandler();系统调用异常处理器的优先顺序为：专用异常处理器，如果没有则调用线程组专用异常处理器，如果以上都没有最后才调用默认处理器。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/05/深入理解内部类（一）/">
                深入理解内部类(一)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-05
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/05/深入理解内部类（一）/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/05/深入理解内部类（一）/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="内部类">内部类</h2><p>把一个类的定义放在另一个类的定义的内部，这种类就是内部类。通过内部类可以把逻辑相关的类组织在一起，通过这种代码隐藏方式，可以有效控制内部类的可见性，不仅如此，内部类了解外围类，并能与之通信。需要知道内部类与类组合是不同的概念。</p>
<p>在外围类的非静态方法里使用内部类的时候，与使用普通类并没有什么不同。一般的比较典型的情况是在外部类中会有一个方法，该方法会返回一个指向内部类的引用。</p>
<p>如果要在外部类的非静态方法之外的位置创建某个内部类对象，就必须要像在main()方法中那样，具体的指明这个对象类型：<strong>OuterClassName.InnerClassName。</strong></p>
<h2 id="链接到外部类">链接到外部类</h2><p>内部类不仅仅是一种名字隐藏和组织代码的模式，这不是内部类最引人注目的用途。当生成一个内部类对象时，这个内部类对象就与制造它的外围对象之间有了一种联系，它能访问其外围对象的所有成员，而不需要任何特殊条件。另外：内部类还拥有其外围类的所有元素的访问权。我们通过Java编程思想一书中的一个例子说明这个特性。首先定义一个接口Selector：</p>
<pre><code><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span></span>{
    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;
    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;
}
</code></pre><p>这个接口有end()、current()、next()三个方法。然后定义类Sequence，并定义其内部类SequenceSelector，让这个内部类实现Selector接口。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>{
    <span class="keyword">private</span> Object[] items;
    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;
    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span></span>{
        items = <span class="keyword">new</span> Object[size];
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>{
        <span class="keyword">if</span>(next &lt; items.length){
            items[next++] = obj;
        }
    }

    <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();
    }

    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span></span>{
        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> index == items.length;
        }
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> items[index];
        }
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>{
            <span class="keyword">if</span>(index &lt; items.length){
                index++;
            }
        }
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{
        Sequence seq = <span class="keyword">new</span> Sequence(<span class="number">10</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++){
            seq.add(Integer.toString(i));
        }
        Selector selector = seq.selector();
        <span class="keyword">while</span>(!selector.end()){
            System.out.print(selector.current()+<span class="string">" "</span>);
            selector.next();
        }
    }
}
</code></pre><p>这是“迭代器”设计模式的一个简单应用，SequenceSelector是提供selector功能的内部private类。<br>这里内部类中的end()、current()、next()方法都用到了外部类的items对象，而且还是外部类的private对象。可见内部类可以访问外部类的所有成员，这为我们编写迭代过程代码提供了极大的方便（编写其他基于内部类与外部类通信的程序也一样）。内部类之所以拥有这样的访问权限其实是在内部类对象被外部类对象被创建的时候，内部类对象会自动捕获一个指向外部类对象的一个引用。在内部类中看上去直接可以访问外部类成员，其实就是这个自动捕获的引用在访问外部类成员。而捕获这个引用的过程是不需要程序员去关心的。</p>
<h2 id="-this与-new">.this与.new</h2><p>如果要在内部类中获取外部类对象的引用，可以使用外部类名字后跟<code>.this</code>.这样产生的引用自动具有正确的类型，这在编译期就可以知晓并受到检查，因此没有任何运行时开销。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OuterClass</span> {
    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">InnerClass</span>{
        <span class="function"><span class="keyword">public</span> OuterClass <span class="title">getOuter</span>(<span class="params"></span>)</span>{
            <span class="keyword">return</span> OuterClass.<span class="keyword">this</span>;
        }
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>{
        OuterClass <span class="keyword">out</span> = <span class="keyword">new</span> OuterClass();
        OuterClass.InnerClass inner = <span class="keyword">out</span>.new InnerClass();
        System.<span class="keyword">out</span>.println(<span class="keyword">out</span> == inner.getOuter());
    }
}
</code></pre><p>可以看到以上代码输出的结果为true；</p>
<p>拥有外部类对象之前是不可能创建内部类的，这是因为内部类对象会自动暗中连接到创建它的外部类对象上。所以我们在main()方法中要创建内部类时必须使用外部类对象去创建内部类，这就是<code>.new</code>语法，例如如下代码方式：</p>
<pre><code>OuterClass <span class="keyword">out</span> = <span class="keyword">new</span> OuterClass();
OuterClass.InnerClass inner = <span class="keyword">out</span>.<span class="keyword">new</span> InnerClass();
</code></pre>
        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  
  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="YIDI" />
          <p class="site-author-name">YIDI</p>
        </div>
        <p class="site-description motion-element">JEE Dadabase BigData Hadoop Spark</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/yidi" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/zelinan" target="_blank">weibo</a>
            </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">Links</p>
            
              <span class="links-of-author-item">
              <a href="http://info.ruc.edu.cn/" target="_blank">RUC INFO</a>
              </span>
            
          
        </div>
        
      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="author">YIDI</span>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.3"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.3"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.3" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"yidi"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  

</body>
</html>
