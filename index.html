<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>


    <meta name="description" content="JEE Dadabase BigData Hadoop Spark" />



  <meta name="keywords" content="YIDI'S BLOG" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> YIDI'S BLOG </title>
</head>

<body>
  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->

  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">YIDI'S BLOG</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<div class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            <i class="menu-item-icon icon-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            <i class="menu-item-icon icon-about"></i> <br />
            关于
          </a>
        </li>
      
    </ul>
  

  
</div>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/08/深入理解内部类（三）/">
                深入理解内部类（三）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-08
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/08/深入理解内部类（三）/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/08/深入理解内部类（三）/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="内部类的作用">内部类的作用</h2><p>以上我们已经谈论了很多内部类的知识，但是这些知识都知识语法和语义层面的，但是内部类真正的作用是什么呢？我们知道内部类可以操作其外部类的成员，也就是说内部类是进入外部类的一个窗口。</p>
<p>如果知识通过内部类实现一个接口，那么其实这完全可以通过让外部类去实现就可以完成，确实，这样没错，如果只是实现一个接口外部类就可以满足，但是事实并不总是这样的，我们直到Java是单继承的，如果要继承多个(接口的)实现外部类就无能为力了，而内部类有效的实现了<strong>多重继承</strong>。每一个内部类都可以独立的继承一个实现，而不论其外部类是否继承了某个实现。</p>
<p>记住，内部类是一个独立的个体，同时外部类的每个内部类都可以以不同的方式实现同一个接口或继承同一个类，这样多重继承的场景就得到了完善。</p>
<h3 id="闭包与回调">闭包与回调</h3><p>闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义可以看出内部类是面向对象的闭包。</p>
<p>通过回调，对象能够携带一些信息，这些信息允许它在稍后的某个时刻调用初始的对象。<br>例如如下的代码：</p>
<p>首先定义一个接口 Incrementable，有一个方法 increment()</p>
<pre><code><span class="keyword">interface</span> <span class="title">Incrementable</span>{
    <span class="function"><span class="keyword">void</span> <span class="title">increment</span>(<span class="params"></span>)</span>;
}
</code></pre><p>然后定义一个类MyIncrement，其与接口有相同的方法increment();</p>
<pre><code><span class="keyword">class</span> <span class="title">MyIncrement</span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span>(<span class="params"></span>)</span>{
        System.<span class="keyword">out</span>.println(<span class="string">"MyIncrement"</span>);
    }
}
</code></pre><p>之后再定义一个Callee类，其继承自 MyIncrement，我们看到其覆写了MyIncrement的increment()方法,如果直接再实现接口我们就不知道覆写的这个increment()到底是实现Incrementable接口的实现还是覆写MyIncrement，因此我们通过一个内部类Closure 实现这个Incrementable接口并实现其对应的increment()方法，这个increment()是一个回调方法，以提供返回Callee的钩子(hook),而且很安全，因为任何人获得这个引用，都只能调用increment()方法，通过Callee.this.increment()回调了Callee类。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Callee</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span></span>{
    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.increment();
        System.out.println(i++);
    }
    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>{
            Callee.<span class="keyword">this</span>.increment();
        }
    }
    <span class="function"><span class="keyword">public</span> Incrementable <span class="title">getCallbackReference</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Closure();
    }
}
</code></pre><p>最后，我们定义一个Caller类，其构造函数需要一个Incrementable引用，之后任意时刻都可以通过此引用回调Callee类。这充分体现了回调的灵活性。</p>
<pre><code><span class="keyword">class</span> <span class="title">Caller</span>{
    <span class="keyword">private</span> Incrementable callbackReference;
    <span class="function"><span class="keyword">public</span> <span class="title">Caller</span>(<span class="params">Incrementable cbh</span>)</span>{
        callbackReference = cbh;
    }
    <span class="function"><span class="keyword">void</span> <span class="title">go</span>(<span class="params"></span>)</span>{
        callbackReference.increment();
    }
}
</code></pre><p>我们写一个测试类进行下测试，代码如下，我们调用了两次cee.increment()，使Callee的变量i增加为2，然后我们通过cer.go()回调Callee，从输出结果看，我们回调到了Callee。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CallBackTest</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        Callee cee = <span class="keyword">new</span> Callee();
        Caller cer = <span class="keyword">new</span> Caller(cee.getCallbackReference());
        cee.increment();
        cee.increment();
        cer.go();
    }
}
</code></pre><h3 id="内部类与控制框架">内部类与控制框架</h3><p>控制框架是一类特殊的应用程序框架，用来解决响应事件的需求，主要用来响应事件的系统被称为事件驱动的系统。Java中典型的事件驱动系统就是GUI。</p>
<p>假设有这样一个控制框架，其工作就是在事件“就绪”的时候执行事件，对于如何执行和控制什么，控制框架并不包含任何具体信息，这些动作都由对应的action()动作完成，这个action是通过继承来提供的，而这里的继承是通过内部类实现的。</p>
<p>下面的抽象类描述了要控制的事件的开始时间，是否就绪，以及一个抽象的action()动作</p>
<pre><code><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>{
    <span class="keyword">private</span> <span class="keyword">long</span> eventTime;
    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">long</span> delayTime;
    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(<span class="keyword">long</span> delayTime)</span></span>{
        <span class="keyword">this</span>.delayTime = delayTime;
        start();
    }
    <span class="comment">/*
     * 可以随时重新设置启动计时器
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>{
        eventTime = System.nanoTime() + delayTime;
    }
    <span class="comment">/*
     * 表示何时可以运行action()方法。
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span></span>{
        <span class="keyword">return</span> System.nanoTime() &gt;= eventTime;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;
}
</code></pre><p>接下来是一个用来管理和触发事件的实际的<strong>控制框架</strong>。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Controller</span> {
    <span class="keyword">private</span> List&lt;Event&gt; eventList = <span class="keyword">new</span> ArrayList&lt;Event&gt;();
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEvent</span>(<span class="params">Event e</span>)</span>{
        eventList.add(e);
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>{
        <span class="keyword">while</span>(eventList.size() &gt;<span class="number">0</span>){
            <span class="keyword">for</span>(Event e: <span class="keyword">new</span> ArrayList&lt;Event&gt;(eventList)){
                <span class="keyword">if</span>(e.ready()){
                    System.<span class="keyword">out</span>.println(e);
                    e.action();
                    eventList.remove(e);
                }
            }
        }
    }
}
</code></pre><p>控制框架循环遍历eventList,寻找就绪的(ready())的事件（event）然后运行它(action())并移除。<br>这里我们其实并不知道Event到底做了什么，怎么做，这正式这个设计的关键所在：<strong>使变化的事务与不变的事务相互分离</strong>，这里不变的就是我们要铜鼓控制框架执行这些Event，而变化的就是这些不同的Event所执行的具体动作。这些正是内部类要做的事情：<br>1、控制框架是由单个类创建的，从而使得实现的细节被封装起来，内部类用来表示解决问题锁必须的各种action()的不同实现。<br>2、内部类可以很容易的访问外部类（这里就是Event）成员，从而可以使这种实现变得简单。</p>
<p>下面是该控制框架的一个特定实现GreenhouseControls：温控室的控制（控制灯光、水、温度及响铃和重启系统等），温控室的各种控制（Event）是非常不同的，但是控制框架的设计使得分离这些不同的代码非常容易。可以在单一的类里产生对同一个基类Event的多种不同实现。</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">GreenhouseControls</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Controller</span> {</span>
    <span class="keyword">private</span> boolean light = <span class="literal">false</span>; <span class="comment">//这里只light演示灯光、温度调节器的控制</span>
    public <span class="class"><span class="keyword">class</span> <span class="title">LightOn</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">LightOn</span>(long delayTime){
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            light = <span class="literal">true</span>;
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Light is on"</span>;
        }
    }
    public <span class="class"><span class="keyword">class</span> <span class="title">LightOff</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">LightOff</span>(long delayTime){
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            light = <span class="literal">false</span>;
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Light is off"</span>;
        }
    }

    <span class="keyword">private</span> <span class="type">String</span> thermostat = <span class="string">"Day"</span>;
    public <span class="class"><span class="keyword">class</span> <span class="title">ThermostatDay</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">ThermostatDay</span>(long delayTime){
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            thermostat = <span class="string">"Day"</span>;
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Thermostat on day setting"</span>;
        }
    }
    public <span class="class"><span class="keyword">class</span> <span class="title">ThermostatNight</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">ThermostatNight</span>(long delayTime){
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            thermostat = <span class="string">"Night"</span>;
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Thermostat on night setting"</span>;
        }
    }

    public <span class="class"><span class="keyword">class</span> <span class="title">Bell</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">Bell</span>(long delayTime){
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            addEvent(<span class="keyword">new</span> <span class="type">Bell</span>(delayTime));
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Bing"</span>;
        }
    }

    public <span class="class"><span class="keyword">class</span> <span class="title">Restart</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        <span class="keyword">private</span> <span class="type">Event</span>[] eventList;
        public <span class="type">Restart</span>(long delayTime,<span class="type">Event</span>[] eventList){
            <span class="keyword">super</span>(delayTime);
            <span class="keyword">this</span>.eventList = eventList;
            <span class="keyword">for</span>(<span class="type">Event</span> e: eventList){
                addEvent(e);
            }
        }
        <span class="annotation">@Override</span>
        public void action() {
            <span class="keyword">for</span>(<span class="type">Event</span> e: eventList){
                e.start();
                addEvent(e);
            }
            start();
            addEvent(<span class="keyword">this</span>);
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Restarting system"</span>;
        }
    }

    public static <span class="class"><span class="keyword">class</span> <span class="title">Terminate</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Event</span>{</span>
        public <span class="type">Terminate</span>(long delayTime) {
            <span class="keyword">super</span>(delayTime);
        }
        <span class="annotation">@Override</span>
        public void action() {
            <span class="type">System</span>.exit(<span class="number">0</span>);
        }
        public <span class="type">String</span> toString(){
            <span class="keyword">return</span> <span class="string">"Terminating system"</span>;
        }
    }
}
</code></pre><p>Light 和 Thermostat 控制比较好理解，Bell控制响铃，然后在事件列表上增加一个Bell对象，于是过一段事件后可以再次响铃。而Restart控制系统重启，一个有Event对象组成的数组被递交给Restart，该数组被加到控制器上，由于Restart本身也是一个Event所以同样可以加到Restart.action()中，以使系统有规律的重新启动自己。</p>
<p>下面的类通过创建GreenhouseControls对象，并添加各种不同的Event对象来配置该系统：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenhouseController</span> </span>{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) {
        GreenhouseControls gc = <span class="keyword">new</span> GreenhouseControls();
        gc.addEvent(gc.<span class="keyword">new</span> Bell(<span class="number">1000</span>));
        Event[] eventList = { gc.<span class="keyword">new</span> LightOn(<span class="number">200</span>), gc.<span class="keyword">new</span> LightOff(<span class="number">400</span>),
                gc.<span class="keyword">new</span> ThermostatNight(<span class="number">0</span>), gc.<span class="keyword">new</span> ThermostatDay(<span class="number">600</span>) };
        gc.addEvent(gc.<span class="keyword">new</span> Restart(<span class="number">2000</span>, eventList));
        gc.addEvent(<span class="keyword">new</span> GreenhouseControls.Terminate(<span class="number">1000000</span>));
        gc.run();
    }
}
</code></pre><p>这个类初始化系统，所以添加了所有响应的事件，Restart事件反复运行，且它每次都会将EventList加载到GreenhouseControls对象中。我们这时就会发现内部类的强大了，特别是在控制框架中，在Java GUI中内部类的作用体现的更为充分。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/07/深入理解内部类（二）/">
                深入理解内部类（二）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-07
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/07/深入理解内部类（二）/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/07/深入理解内部类（二）/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="内部类向上转型">内部类向上转型</h2><p>内部类可以向上转型为其基类或其实现的接口，这个时候内部类就有了较大的用武之地，因为内部类作为某个接口的实现能够完全不可见并且不可用，外围所得到的只是基类或实现接口的引用，因此可以非常方便的隐藏实现细节，例如对应一个private的内部类，给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，完全隐藏实现细节，对于外部调用者，由于不能访问实现类任何新增的，原本不属于公共接口的方法，所以扩展接口是没有意义也是不可能的，这样给Java编译器提供了生产更高效代码的条件，同时也更好的保护了实现类的内部细节。例如如下代码：<br>我们首先定义一个公共接口Course，该接口返回一个课程名。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Course</span> {
    <span class="function">String <span class="title">getCourseName</span>(<span class="params"></span>)</span>;
}
</code></pre><p>然后我们定义一个CourseImpl类，其内部类CourseInnerImpl真正实现Course接口：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="function"><span class="keyword">public</span> CourseInnerImpl <span class="title">getCourseInnerImpl</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> CourseInnerImpl();
    }
    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseInnerImpl</span> <span class="keyword">implements</span> <span class="title">Course</span></span>{
        String coursePref = <span class="string">"CS:"</span>;
        String[] course ={<span class="string">"C++"</span>,<span class="string">"Java"</span>};
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> coursePref +course[Math.abs(r.nextInt()%<span class="number">2</span>)];
        }
    }
}
</code></pre><p>最后我们在第三个类TestCourse里访问Course接口的功能：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestCourse</span> {
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>{
        CourseImpl ci = <span class="keyword">new</span> CourseImpl();
        Course c = ci.getCourseInnerImpl();
        <span class="comment">//CourseInnerImpl = c2 = ci.getCourseInnerImpl(); 错误</span>
        System.<span class="keyword">out</span>.println(c.getCourseName());
        System.<span class="keyword">out</span>.println(c.getCourseName());
        System.<span class="keyword">out</span>.println(c.getCourseName());
    }
}
</code></pre><p>可以看到我们只能获取到内部类向上转型后的公共接口Course类型，而不能访问到其具体实现CourseInnerImpl类型，即使getCourseInnerImpl()返回的类型是CourseInnerImpl，这样内部类就做到了实现细节的隐藏，外部只需要并只能关注公共接口提供的信息而不能访问内部类的细节。</p>
<h2 id="在方法和作用域内的内部类-局部内部类">在方法和作用域内的内部类-局部内部类</h2><p>到目前为止我们探讨的内部类都是定义在类作用域内的内部类，其实内部类的用法远不止如此，我们可以在方法内或者任何作用域内定义内部类，这样的内部类称为局部内部类。</p>
<p>例如，我们可以把上面的CourseImpl类改写成如下方式，CourseInnerImpl类在方法getCourseInnerImpl内，作为一个局部内部类存在，这样，不仅其他类不能访问该内部类，就是类自身除了方法getCourseInnerImpl外都不能访问内部类的具体实现了。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="function"><span class="keyword">public</span> Course <span class="title">getCourseInnerImpl</span><span class="params">()</span></span>{
        <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseInnerImpl</span> <span class="keyword">implements</span> <span class="title">Course</span></span>{
            String coursePref = <span class="string">"CS:"</span>;
            String[] course ={<span class="string">"C++"</span>,<span class="string">"Java"</span>};
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>{
                <span class="keyword">return</span> coursePref +course[Math.abs(r.nextInt()%<span class="number">2</span>)];
            }
        }
        <span class="keyword">return</span> <span class="keyword">new</span> CourseInnerImpl();
    }
}
</code></pre><p>我们也可以改写为让内部类在方法的某个作用域内，例如：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="function"><span class="keyword">public</span> Course <span class="title">getCourseInnerImpl</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>{
        <span class="keyword">if</span>(flag){
            <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseInnerImpl</span> <span class="keyword">implements</span> <span class="title">Course</span></span>{
                String coursePref = <span class="string">"CS:"</span>;
                String[] course ={<span class="string">"C++"</span>,<span class="string">"Java"</span>};
                <span class="annotation">@Override</span>
                <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>{
                    <span class="keyword">return</span> coursePref +course[Math.abs(r.nextInt()%<span class="number">2</span>)];
                }
            }
            <span class="keyword">return</span> <span class="keyword">new</span> CourseInnerImpl();
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</code></pre><p>这并不是说只有满足条件才会创建这个内部类，它其实和其他类一样已经编译了，但是在定义该内部类的作用域之外它是不可用的，除此之外与其他普通类没有任何区别。</p>
<h2 id="匿名内部类">匿名内部类</h2><p>匿名内部类就是没有名字的内部类，比如如下代码：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="function"><span class="keyword">public</span> Course <span class="title">getCourseInnerImpl</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Course(){
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>{
                <span class="keyword">return</span> <span class="string">"CLASS NAME"</span>;
            }
        };
    }
}
</code></pre><p>其中的</p>
<pre><code><span class="keyword">return</span> <span class="keyword">new</span> Course(){
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function">String <span class="title">getCourseName</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"CLASS NAME"</span>;
    }
}
</code></pre><p>就是创建了一个实现了Course接口的匿名内部类，其等价于上面提到的在方法内实现的内部类，<code>new</code>表达式返回的引用自动向上转型为Course类型。如果基类需要有参数的构造器，对于匿名内部类，我们同样可以实现：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="keyword">public</span> <span class="function">Course <span class="title">getCourseInnerImpl</span><span class="params">(String name)</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> MyCourse(name){
            <span class="annotation">@Override</span>
            <span class="keyword">public</span> <span class="function">String <span class="title">getCourseName</span><span class="params">()</span> </span>{
                <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">getName</span><span class="params">()</span></span>;
            }
        };
    }
}
</code></pre><p>其中MyCourse是Course接口的一个实现，其有一个参数，这里直接将参数传递给new MyCourse（String name）即可。如果直接使用<code>return name</code>是不行的会导致编译错误，此时我们必须保证传入的参数是final的才可以。之所以我们这里用到<code>return super.getName()</code>进行返回可以，是因为在匿名内部类中不直接用到name。<br>例如：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseImpl</span></span>{
    Random r = <span class="keyword">new</span> Random(<span class="number">48</span>);
    <span class="function"><span class="keyword">public</span> Course <span class="title">getCourseInnerImpl</span><span class="params">(<span class="keyword">final</span> String name)</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> MyCourse(name){
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>{
                <span class="keyword">return</span> name;
            }
        };
    }
} 
</code></pre><p>内部类虽然可以扩展类，也可以实现接口，但是并不能两者兼备，而且实现接口的时候也只能实现一个接口，同样，由于没有名字，在匿名内部类中不可能有命名构造器，只能通过实例初始化方式达到构造器的效果，但是由于不能重载实例初始化方法，所以匿名内部类也只有一个“构造器”。</p>
<h2 id="嵌套类">嵌套类</h2><p>嵌套类一般的指静态内部类，即static class，静态内部类和普通类有以下不同：<br>1、创建静态内部类对象时，不需要其外部类的对象<br>2、不能从静态内部类的对象中访问非静态的外部类对象<br>3、静态内部类可以有static字段和数据，而普通内部类不可以。</p>
<p>另外嵌套类还有如下表示形式，可以看到不管嵌套多少层，内部类都可以透明的访问其所有外部类的成员，并且内部类的创建也会自然的自动根据其直接外部类创建。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;
    <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span></span>{
        <span class="keyword">private</span> <span class="keyword">int</span> b = a + <span class="number">1</span>;
        <span class="class"><span class="keyword">class</span> <span class="title">ClassC</span></span>{
            <span class="keyword">private</span> <span class="keyword">int</span> c = a + b + <span class="number">1</span>;
            <span class="class"><span class="keyword">class</span> <span class="title">ClassD</span></span>{
                <span class="keyword">private</span> <span class="keyword">int</span> d = a + b + c +<span class="number">1</span>;
            }
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args){
        ClassA a = <span class="keyword">new</span> ClassA();
        ClassA.ClassB b = a.<span class="keyword">new</span> ClassB();
        ClassA.ClassB.ClassC c = b.<span class="keyword">new</span> ClassC();
        ClassA.ClassB.ClassC.ClassD d= c.<span class="keyword">new</span> ClassD();
    }
}
</code></pre>
        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/07/Java并发编程（二）/">
                Java并发编程（二）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-07
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/07/Java并发编程（二）/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/07/Java并发编程（二）/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>这篇简单介绍线程资源共享即同步问题。</p>
<p>多线程各自运行，你就无法确定一个线程何时在运行，当前哪个线程在运行。这在对<strong>临界资源</strong>访问时就肯定会出现问题，假设如果两个线程试图同时获取一个相同的资源的时候，如果不加以控制，就可能至少有其中一个线程访问到状态不正确的资源，因此使用线程时一个重要的工作就是进行线程的同步。基本上并发模式在解决线程冲突问题的时候基本上都是采用序列化访问共享资源的方案，不同的场景有具体的不同处理方式。</p>
<h2 id="1-Synchronized_&amp;_Lock">1.Synchronized &amp; Lock</h2><p>Java中通过synchronized 关键字为资源冲突提供了内置支持，当任务要执行被synchronized 保护的代码时，会<strong>先检查锁是否可用，之后获取锁，然后执行代码，最后释放锁</strong>。<br>所有的共享资源一般是以对象的形式存在内存片段中，但也可以是文件，IO端口，打印机等。要控制对共享资源的访问，先要将其包装进一个对象，然后把所有要访问这个资源的方法标记为synchronized。如<strong>果某个任务处于对标记为synchronized 的方法的调用中，那么在这个任务从该方法返回前，其他所有要调用该被标记为synchronized 的方法的任务都会被阻塞</strong>。<br>所有对象都自动含有单一的锁，当<strong>一个任务</strong>在对象上调用其任意的synchronized 方法时，此对象都被加锁。这时<strong>其他任何任务</strong>要调用该对象上其他的synchronized 方法只有等到前一个synchronized 方法调用完毕并释放了锁之后才能被调用。<br>一个任务可以多次获得对象的锁，如果该任务已经获得当前对象的锁，那么它在调用了该对象的synchronized 方法后，如果该方法需要继续调用对象的另一个synchronized 方法是可以的，JVM负责跟踪和维护对象被加锁的次数，如果对象被第一次加锁，则计数器为1，下一次加锁计数器为2，直到完全释放，计数器变为0，此时其他任务就可以调用对象的synchronized 方法了，但是在计数器不为0的时候，只有当前已经获取到锁的任务可以调用对象的synchronized 方法。<br>针对每一个类，也有一个锁 。synchronized static 可以保证在类的范围内防止对static数据的并发访问。<br>如果在类中有超过一个方法在处理临界资源，那必须同步所有处理这些资源的相关方法，否则并发就不能正常工作。<br> 除了使用synchronized 之外，还可以使用Lock进行显示的加锁操作，显示的加锁比synchronized 更灵活，具有更细粒度的操作，可以在锁失败时可以做一些清理工作，显示的锁操作必须使用try catch finally语句，并且数据返回必须在try语句块中，以确保unlock()不会过早发声，将数据暴露给其他任务，而且必须有finally语句块，在其中处理unlock()操作。显示的加锁操作比synchronized赋予了更灵活的特性，但是维护起来比synchronized 跟复杂，代码也更更容易出错，但是由于显示加锁允许做更多的控制，因此适用范围更广。</p>
<h2 id="2-Volatile">2.Volatile</h2><p>在Java中<strong>不能依赖原子性就不使用同步</strong>，volatile关键字修饰属性主要是为了<strong>保证可视性但不保证互斥</strong>，因为一般情况下，线程对域的修改即使是不中断的原子操作，对其他任务也可能是不可见的，因为此时的修改可能只是暂时性的存储在线程的本地处理器的缓存中（不强制必须刷到主存中），不同任务对应用有不同的视图，volatile 保证了如果一个域一旦发生了写操作，就强制将修改立即写入主存中，这样就保证了修改的可视性。<br>当一个域的值依赖于它之前的值或者一个域的值依赖其他域的值，那么volatile就无法正常工作了，使用volatile而不是使用synchronized唯一安全的情况是类中只有一个可变的域。第一选择是使用synchronized而不是有风险的volatile。同一个变量线程之间的可见性和线程中相互操作的互斥性是两件事情。操作互斥是提供了操作整体的原子性，千万不能混淆。</p>
<h2 id="3-Atomic">3.Atomic</h2><p>在concurrent包中，实现了多个特殊的元自行变量类型，对这些类型使用原子性操作不需要使用synchronized等同步机制而可以保证正确性。Atomic类型性能比使用同步更好，JDK是通过JNI的方式使用了硬件支持的CAS指令，一般的我们更倾向于使用synchronized或者Lock等方式，而避免可能的安全性问题，除非有特别的性能要求。</p>
<h2 id="4-临界区">4.临界区</h2><p>有时候，你并不需要对整个方法进行同步，而只需要对方法中的部分临界资源进行同步，通过这种方式分离出来的代码段被称为临界区，它也可以使用synchronized建立，此时需要在synchronized中指定一个对象，表示此对象的锁被用来对括号内的代码进行同步控制，这段代码就称为临界区，也即同步控制块，在进入这段代码前必须获取同步对象的锁，否则只能等待，通过使用同步控制块而不是使用整个方法的同步控制。可以使多个任务访问对象的时间性能得到显著提高。<br>synchronized块一般的用法是在当前对象上加锁，即synchronized(this)，此时其他任务就不能对该对象的所有其他synchronized进行调用了。但是如果当前对象的不同的synchronized 块加锁的对象是不一样的，则加锁对象不一样的同步控制块彼此不是互斥的，也即一个任务在访问该对象的synchronized(Object1)同步控制块时，另一个任务也可以同时访问该对象的另一个同步控制块synchronized(Obeject2).<br>如果需要对一个非线程安全的类进行线程安全的操作，我们可以创建一个该类的Manager类，通过在该Manager类中的同步方法访问该类从而实现非线程安全的类的线程安全的访问。 </p>
<h2 id="5-线程本地存储">5.线程本地存储</h2><p>为了对每个线程都创建变量的本地存储，可以使用concurrent.ThreadLocal类，这样每个线程都会创建自己线程的本地存储变量，线程之间不共享该变量，也就不需要同步控制了。例如：TreadLocal<integer> 。</integer></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/05/Java并发编程（一）/">
                Java并发编程（一）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-05
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/05/Java并发编程（一）/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/05/Java并发编程（一）/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>Java中的并发就是指多线程编程，并发编程可以使我们将程序划分为多个分离的，独立运行的任务。每一个任务都由执行线程来驱动。线程用于驱动任务，因此需要一种描述任务的方式，在Java中由Runnable接口来提供。要想定义一个基于线程驱动的任务，只需要实现Runnable接口，并编写其run()方法，在其中实现你的任务需要实现的功能。<br>任务的run()方法通常来讲总是以某种形式的循环实现，这样这个任务就可以一直执行下去，直到满足一定的条件不再需要执行为止，这个满足一定条件就是跳出循环的条件。这里的Runnable 和run()方法不具备执行的能力，它必须显示的依附于一个线程上，因此叫做线程驱动任务。</p>
<h2 id="1-Thread类">1.Thread类</h2><p>Thread类是Java并发最基础也是最核心的线程类，最基本的要让一个Runnable接口转变成一个可执行的任务就是将其提交给一个Thread对象，然后调用Thread对象的start()方法使其运行，此时线程就会自动驱动Runnable任务并执行其run()方法。</p>
<pre><code><span class="keyword">Thread</span> t <span class="subst">=</span> <span class="literal">new</span> <span class="keyword">Thread</span>(<span class="literal">new</span> 一个Runnable对象)
t<span class="built_in">.</span>start();
</code></pre><p>这里用Runnable接口构建了一个Thread对象，并且这个Thread对象通过调用其start()方法对Runnable的run()方法进行调用，之后run()就可以执行一系列的动作了，start()方法在调用了run()方法后会很快返回，然后主线程（调用start方法的线程）可以继续执行接下来的动作。而于此同时也产生了一个新线程，它就是执行run()的线程，这两个线程在这种情况下没有任何同步，完全是随操作系统和JDK的调用执行自己的任务。</p>
<p>例如下面的程序就是main线程驱动了一个新的线程，然后这两个线程根据操作系统和JDK的调用执行，直到flag标志变为false时MyRunnable才从run()方法反回。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExecuteRunnable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;
    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="comment">//直到flag为false才停止执行</span>
            <span class="keyword">while</span>(flag == <span class="keyword">true</span>){
                System.out.println(<span class="string">"I'm MyRunnable tread!"</span>);
            }
        }
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="comment">// <span class="doctag">TODO</span> Auto-generated method stub</span>
        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());
        t.start();
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)
            System.out.println(<span class="string">"I'm MAIN thread!"</span>);
        flag = <span class="keyword">false</span>;
    }
}
</code></pre><p>需要说明的是，如果在main线程的最后没有对flag进行置false操作，MyRunnable就会一直执行无限执行下去。main()方法创建了Thread t之后并没有捕获任何对其的引用，而我们知道Java的垃圾回收机制会对没用引用的死对象就行回收，但是这里的线程t不仅没被及时回收，而且在main结束之后还会一直执行下去，这是因为虽然main没有捕获Thread t的引用，但是每个线程都会进行自我注册，因此实际上有一个对其的引用，直到其从run()返回。</p>
<h2 id="2-Executor">2.Executor</h2><p>如上我们通过显示的创建一个Thread对象来驱动一个具体的任务，然而在Java的并发模型中提供了一个更好的实现方式Executor，其为我们管理Thread对象，简化并发编程，它在客户端和任务之间提供了一个间接层，不用客户显示的执行任务，任务由它去执行并管理，而无需显示的管理线程的生命周期。Executor 知道如何恰当的构建上下文来执行Runnable对象，我们通过Executors类的静态方法创建不同类型的Executor.</p>
<pre><code>ExecutorService <span class="keyword">exec</span> = Exectors.newCachedThreadPool();
<span class="keyword">exec</span>.executor(new 一个Runnable对象);
<span class="keyword">exec</span>.<span class="keyword">shutdown</span>();
</code></pre><p>这里的单个exec可以被用来创建和管理系统中所有的任务，这里的exec类型为每一个提交给它的任务都通过调用executor创建一个新的线程执行，最后调用shutdown()方法是为了防止有新的任务被提交给这个exec对象。</p>
<pre><code><span class="keyword">package</span> examples.concurrent.java;
<span class="keyword">import</span> java.util.concurrent.ExecutorService;
<span class="keyword">import</span> java.util.concurrent.Executors;
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadExecuteRunnable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;
    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
    <span class="keyword">int</span> id;
        <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(<span class="keyword">int</span> id)</span></span>{
            <span class="keyword">this</span>.id = id;
        }
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            <span class="comment">//直到flag为false才停止执行</span>
            <span class="keyword">while</span>(flag == <span class="keyword">true</span>){
                System.out.println(<span class="string">"I'm MyRunnable tread-"</span> + id);
                Thread.yield();
            }
            System.out.println(<span class="string">"I'm Returned tread-"</span> + id);
        }
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="comment">// <span class="doctag">TODO</span> Auto-generated method stub</span>
        ExecutorService exec = Executors.newCachedThreadPool();
        <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++){
            exec.execute(<span class="keyword">new</span> MyRunnable(i));
        }
        exec.shutdown();<span class="comment">//如果注释掉这句话，程序将一直执行并等待。</span>
        System.out.println(<span class="string">"I'm MAIN thread!"</span>);
        flag = <span class="keyword">false</span>;
    }
}
</code></pre><p>从上面的代码中可以看到，我们没有显示的创建驱动任务的Thread而是通过Executor管理并执行了多个线程，同时注意如果没有调用exec.shutdown()，程序会一直运行并等待新的任务的提交，因此当我们明确没有任务要执行的时候就需要调用shutdown将其Executor服务关掉。</p>
<p>通常我们首选的Executor是CachedThreadPool,它会在程序执行过程中创建与所需数据相同的线程，并且在有旧线程被回收的时候停止创建新的线程，而如果这种方式可能出现问题的时候我们也可以选择使用FixedThreadPool,它将会创建固定数据的线程，可以预先创建创建对应数据的线程，不用每次为新来的任务创建对应的线程而产生创建线程的开销，一旦任务数多于对应的线程数，就会产生等待。另一种特殊的固定线程的是SingleThreadExecutor,顾名思义只创建一个线程，是线程数量为1的FixedThreadPool,这个执行器可以隐式的使任务根据其提交的先后顺序进行排队，即序列化任务。</p>
<h2 id="3-Callable">3.Callable</h2><p>Runnable不返回值。如果需要返回值，则可以实现Callable接口，它有一个类型参数,并且对应的方法是call()，对应的调用方法是Executor.submit()。该调用返回一个Future对象，并使用call()返回的结果进行了参数化，例如call()返String类型，则返回的是Future<string>对象，通过Future对象的get()方法可以获取最终的返回值。</string></p>
<h2 id="4-休眠、优先级、让步、后台线程、JOIN">4.休眠、优先级、让步、后台线程、JOIN</h2><p><strong>休眠：</strong>通过TimeUnit对应的sleep()方法，其使当前线程休眠一段时间（阻塞），sleep()方法可以抛出InterruptedException，我们需要在本地（当前线程）处理这个异常，因为异常不能跨线程传播，我们需要明确的是不能依赖sleep函数去控制程序的顺序，必须使用同步控制。</p>
<p><strong>优先级：</strong>调度器倾向于让优先级高的线程先执行，但是优先级低的也仍然有机会执行，这并不会导致死锁。不同的操作系统对JDK优先级的映射也不同，一般情况下我们不应该对线程设置优先级，最多只使用MAX_PRIORITY NORM_PRIORITY MIN_PRIORITY三个级别。例如：Thread.currentThread().setPriority(MAX_PRIORITY).</p>
<p><strong>让步：</strong>通过调用Thread.yield()暗示当前线程可以让步，其他线程可以运行，但是这只是一种建议，类似于gc()一样，没有任何机制保障一定会让步，我们也不能依赖它。</p>
<p><strong>后台线程：</strong>所谓后台线程就是在程序运行的时候提供一种通用的服务的线程，并且这种线程不属于程序中不可或缺的部分，当所有的非后台线程结束时，后台线程会全部被杀死。如果非后台线程还在运行，程序就不会终止。后台线程必须在调用start()之前先调用setDaemon()方法才能设置为后台线程。需要说明的是：后台线程创建的任何线程都是后台线程，即使被创建的线程并没有声明为后台线程，后台线程会在非后台线程都结束的时候直接从run()方法返回，连最后的finally子句都不会执行，因此我们无法优雅的关掉后台线程。</p>
<p><strong>JOIN:</strong>一个线程可以在其他线程上调用join，而等待这个线程醒来，此时，当前线程将会挂起，而直到目标线程（也就是被在其上调用Join的线程）结束。当然对join的调用可以被interrupt()方法中断，因此需要用try catch语句，当一个线程在另一个线程上调用interrupt()时将给该线程设定一个标志，表明线程已经被中断，但是在异常捕获时将清除这个标志，所以在catch子句中，isInterrupted()标志总是为false。其实在JDK5之后的的concurrent包中有CyclicBarrier比join更好用。</p>
<h2 id="5-异常的捕获">5.异常的捕获</h2><p>请记住，一旦异常从线程的run()方法逃逸出来，它就会向外传送到控制台，不能用普通的异常处理机制try catch语句进行捕获，例如下面的线程总是会在run()中抛出一个异常，而在对应代码段加上try catch语句是无效的，仍旧会抛出对应的异常。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="keyword">try</span> {
            ExecutorService exec = Executors.newCachedThreadPool();
            exec.execute(<span class="keyword">new</span> ExceptionThread());
        } <span class="keyword">catch</span> (Exception e) {
        }
    }
｝
</code></pre><p>Thread.UncaughtExceptionhandler是JDK5中的一个新接口。它允许在每个Thread上都附着一个异常处理器，Thread.UncaughtExceptionhandler.uncaughtException()会在线程因未捕获异常而死亡时被调用。接下来我们的工作就是在用Executor产生线程时为每个线程对象都附着一个Thread.UncaughtExceptionhandler。<br>Executors创建线程除了可以使用无参的方法，还可以为方法传递一个ThreadFactory对象，而这里我们就是利用这个ThreadFactory对象为我们的线程附着Thread.UncaughtExceptionhandler。示例代码如下：</p>
<pre><code><span class="keyword">class</span> <span class="title">HandlerThreadFactory</span> <span class="title">implements</span> <span class="title">ThreadFactory</span>{

    @<span class="function">Override
    <span class="keyword">public</span> Thread <span class="title">newThread</span>(<span class="params">Runnable r</span>) </span>{
        System.<span class="keyword">out</span>.println(<span class="keyword">this</span> + <span class="string">"Create new Thread!"</span>);
        Thread t = <span class="keyword">new</span> Thread(r);
        System.<span class="keyword">out</span>.println(t);
        t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHander());
        System.<span class="keyword">out</span>.println(t.getUncaughtExceptionHandler());
        <span class="keyword">return</span> t;
    }
}
</code></pre><p>可以看到，实现ThreadFactory需要实现其中的newThread()方法，这里就是我们要创建的线程，我们的工厂类HandlerThreadFactory 就是在这里通过setUncaughtExceptionHandler()方法为我们的线程附着上默认的异常处理器。<br>可以看到我们创建了工厂，还需要创建对应的异常处理器，这里是MyUncaughtExceptionHander，其示例代码如下，它需要实现我们上面提到的Thread.UncaughtExceptionHandler接口并且实现其中的uncaughtException()方法，这个方法就是正式处理异常要调用的方法。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHander</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>{
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>{
        System.out.println(<span class="string">"Catch this:"</span> + e);
    }
}
</code></pre><p>这时，我们将我们的工厂传递给Executors对应的方法后，新创建的线程在run()中抛出的异常就会被捕获。完整代码如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThreadWithUncaughtExceptionHandler</span> </span>{
    <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHander</span> <span class="keyword">implements</span>         <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>{
            System.out.println(<span class="string">"Catch this:"</span> + e);
        }    
    }
    <span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>{
            System.out.println(<span class="keyword">this</span> + <span class="string">"Create new Thread!"</span>);
            Thread t = <span class="keyword">new</span> Thread(r);
            System.out.println(t);
            t.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHander());
            System.out.println(t.getUncaughtExceptionHandler());
            <span class="keyword">return</span> t;
        }
    }
    <span class="class"><span class="keyword">class</span> <span class="title">ExceptionThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
            Thread t = Thread.currentThread();
            System.out.println(<span class="string">"run by :"</span> + t);
            System.out.println(<span class="string">"en:"</span> + t.getUncaughtExceptionHandler());
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();
        }    
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        ExceptionThreadWithUncaughtExceptionHandler it = <span class="keyword">new</span> ExceptionThreadWithUncaughtExceptionHandler();
        <span class="comment">//Thread.setDefaultUncaughtExceptionHandler(it.new MyUncaughtExceptionHander());</span>
        ExecutorService exec = Executors.newCachedThreadPool(it.new HandlerThreadFactory());
        exec.execute(it.new ExceptionThread2());
    }
}
</code></pre><p>我们可以根据需要为我们的线程逐个设置异常处理器，但是如果我们知道在代码中需要处处使用相同的异常处理器，那么我们可以在Thread类中设置一个静态阈来设置所有线程的默认异常处理器。其用法为：Thread.setDefaultUncaughtExceptionHandler();系统调用异常处理器的优先顺序为：专用异常处理器，如果没有则调用线程组专用异常处理器，如果以上都没有最后才调用默认处理器。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/05/深入理解内部类（一）/">
                深入理解内部类(一)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-05
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/CoreJava/">CoreJava</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/05/深入理解内部类（一）/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/05/深入理解内部类（一）/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="内部类">内部类</h2><p>把一个类的定义放在另一个类的定义的内部，这种类就是内部类。通过内部类可以把逻辑相关的类组织在一起，通过这种代码隐藏方式，可以有效控制内部类的可见性，不仅如此，内部类了解外围类，并能与之通信。需要知道内部类与类组合是不同的概念。</p>
<p>在外围类的非静态方法里使用内部类的时候，与使用普通类并没有什么不同。一般的比较典型的情况是在外部类中会有一个方法，该方法会返回一个指向内部类的引用。</p>
<p>如果要在外部类的非静态方法之外的位置创建某个内部类对象，就必须要像在main()方法中那样，具体的指明这个对象类型：<strong>OuterClassName.InnerClassName。</strong></p>
<h2 id="链接到外部类">链接到外部类</h2><p>内部类不仅仅是一种名字隐藏和组织代码的模式，这不是内部类最引人注目的用途。当生成一个内部类对象时，这个内部类对象就与制造它的外围对象之间有了一种联系，它能访问其外围对象的所有成员，而不需要任何特殊条件。另外：内部类还拥有其外围类的所有元素的访问权。我们通过Java编程思想一书中的一个例子说明这个特性。首先定义一个接口Selector：</p>
<pre><code><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span></span>{
    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;
    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;
    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;
}
</code></pre><p>这个接口有end()、current()、next()三个方法。然后定义类Sequence，并定义其内部类SequenceSelector，让这个内部类实现Selector接口。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>{
    <span class="keyword">private</span> Object[] items;
    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;
    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span></span>{
        items = <span class="keyword">new</span> Object[size];
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>{
        <span class="keyword">if</span>(next &lt; items.length){
            items[next++] = obj;
        }
    }

    <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();
    }

    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span></span>{
        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> index == items.length;
        }
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> items[index];
        }
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>{
            <span class="keyword">if</span>(index &lt; items.length){
                index++;
            }
        }
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{
        Sequence seq = <span class="keyword">new</span> Sequence(<span class="number">10</span>);
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++){
            seq.add(Integer.toString(i));
        }
        Selector selector = seq.selector();
        <span class="keyword">while</span>(!selector.end()){
            System.out.print(selector.current()+<span class="string">" "</span>);
            selector.next();
        }
    }
}
</code></pre><p>这是“迭代器”设计模式的一个简单应用，SequenceSelector是提供selector功能的内部private类。<br>这里内部类中的end()、current()、next()方法都用到了外部类的items对象，而且还是外部类的private对象。可见内部类可以访问外部类的所有成员，这为我们编写迭代过程代码提供了极大的方便（编写其他基于内部类与外部类通信的程序也一样）。内部类之所以拥有这样的访问权限其实是在内部类对象被外部类对象被创建的时候，内部类对象会自动捕获一个指向外部类对象的一个引用。在内部类中看上去直接可以访问外部类成员，其实就是这个自动捕获的引用在访问外部类成员。而捕获这个引用的过程是不需要程序员去关心的。</p>
<h2 id="-this与-new">.this与.new</h2><p>如果要在内部类中获取外部类对象的引用，可以使用外部类名字后跟<code>.this</code>.这样产生的引用自动具有正确的类型，这在编译期就可以知晓并受到检查，因此没有任何运行时开销。</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OuterClass</span> {
    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">InnerClass</span>{
        <span class="function"><span class="keyword">public</span> OuterClass <span class="title">getOuter</span>(<span class="params"></span>)</span>{
            <span class="keyword">return</span> OuterClass.<span class="keyword">this</span>;
        }
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>{
        OuterClass <span class="keyword">out</span> = <span class="keyword">new</span> OuterClass();
        OuterClass.InnerClass inner = <span class="keyword">out</span>.new InnerClass();
        System.<span class="keyword">out</span>.println(<span class="keyword">out</span> == inner.getOuter());
    }
}
</code></pre><p>可以看到以上代码输出的结果为true；</p>
<p>拥有外部类对象之前是不可能创建内部类的，这是因为内部类对象会自动暗中连接到创建它的外部类对象上。所以我们在main()方法中要创建内部类时必须使用外部类对象去创建内部类，这就是<code>.new</code>语法，例如如下代码方式：</p>
<pre><code>OuterClass <span class="keyword">out</span> = <span class="keyword">new</span> OuterClass();
OuterClass.InnerClass inner = <span class="keyword">out</span>.<span class="keyword">new</span> InnerClass();
</code></pre>
        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/04/单元测试工具-MOCK/">
                单元测试工具-MOCK
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2015-07-04
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分类于
            
              <a href="/categories/UnitTest/">UnitTest</a>

              
              

            
          </span>
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2015/07/04/单元测试工具-MOCK/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/04/单元测试工具-MOCK/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>我们在编写程序的过程中，离不开测试，测试又分为单元测试和集成测试。集成测试有著名的Jenkins平台，测试人员可以很方便的在上面部署集成测试任务进行测试.地址：<a href="http://jenkins-ci.org/" title="Jenkins" target="_blank" rel="external">http://jenkins-ci.org/</a> 但是在开发和单元测试阶段，我们更关注单元测试，相信不少人也正在用很多测试框架，例如：<a href="http://junit.org/" title="Junit" target="_blank" rel="external">Junit</a>,<a href="http://testng.org/doc/index.html" title="TestNG" target="_blank" rel="external">TestNG</a> 等JVM平台的单元测试框架。这些都是非常流行好用的测试工具。</p>
<h2 id="Mock介绍">Mock介绍</h2><p>实际工作中我们可能会遇到类似下面的情况：</p>
<p>我们写了一个函数，函数需要调用其他模块或者服务获取结果，然后我们的函数对获取到的结果进行处理并返回处理后的结果。这里的服务可能是远程服务调用也可能是数据库服务调用，那么我们如果要对这个函数进行单元测试就一定需要保证远程服务调用当前或者当前数据库服务可用么？</p>
<p>答案是：不用。</p>
<p>一方面为了进行一个简单的单元测试就要调用服务显然太浪费，在资源使用上也不合理，另一方面远程服务或者数据库服务可能也正在开发或者还没有开始开发，我们也不能因此就不进行单元测试。这种情况正是Mock发挥威力的时候。</p>
<p>Mock简单来说就是为我们模拟单元测试中需要使用到的其他资源并提供资源对应的服务而简化单元测试工作，使单元测试与其依赖的服务解耦。</p>
<p>下面我们写一个具体的例子，我们使用的Mock工具为Mockito，我们模拟的单元测试需要的服务是一个数据库服务。</p>
<h2 id="Maven依赖">Maven依赖</h2><p>假设使用版本是1.8.5，则在Maven项目中POM.xml配置依赖：</p>
<pre><code><span class="tag">&lt;<span class="title">dependency</span>&gt;</span>
     <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span>
     <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>mockito-all<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span>
    <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.8.5<span class="tag">&lt;/<span class="title">version</span>&gt;</span>
    <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dependency</span>&gt;</span>
</code></pre><h2 id="Mock使用示例">Mock使用示例</h2><p>我们写了一个DBController类，其主要任务是调用数据库服务，获取当前用户的信息并返回是否成功，代码如下：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBController</span> </span>{
    <span class="keyword">private</span> DBService dbService;
    <span class="function"><span class="keyword">public</span> <span class="title">DBController</span><span class="params">(DBService dbService)</span></span>{
        <span class="keyword">this</span>.dbService = dbService;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getUserInfoData</span><span class="params">(Map&lt;String,Useruser)</span></span>{
        user.put(<span class="string">"user"</span>, dbService.getUserInfoData());
        <span class="keyword">return</span> user.size() <span class="number">0</span>;
    }
}
</code></pre><p>要对其进行单元测试我们就需要模拟出一个DBService类的对象，并提供对应的getUserInfoData()方法实现。</p>
<p>使用Mock的如下代码可以模拟出一个DBService对象：</p>
<pre><code>DBService dbService = Mockito.mock(DBService.<span class="keyword">class</span>);
</code></pre><p>然后我们知道getUserInfoData()方法会返回一个User对象，因此我们可以用如下代码模拟这个方法的实现：</p>
<pre><code>User expectedUser =new User<span class="params">(<span class="string">"User1"</span>)</span>;
Mockito.when<span class="params">(dbService.getUserInfoData<span class="params">()</span>)</span>.thenReturn<span class="params">(expectedUser)</span>;
</code></pre><p>这两行代码表示当调用dbService.getUserInfoData()方法时就会返回我们声明的expectedUser对象。</p>
<p>我们所需要的数据库服务已经完全用Mock模拟出来了，接下来就可以开始单元测试了，我们结合使用TestNG进行单元测试，代码如下：</p>
<pre><code>public class DBControllerTest {

    @Test
    public void testMethod_getUserInfoData<span class="params">()</span>{
        User expectedUser =new User<span class="params">(<span class="string">"User1"</span>)</span>;
        DBService dbService = Mockito.mock<span class="params">(DBService.class)</span>;
        Mockito.when<span class="params">(dbService.getUserInfoData<span class="params">()</span>)</span>.thenReturn<span class="params">(expectedUser)</span>;
        DBController dbController = new DBController<span class="params">(dbService)</span>;
        HashMap&lt;String,User&gt; user = new HashMap&lt;String,User&gt;<span class="params">()</span>;
        boolean succ = dbController.getUserInfoData<span class="params">(user)</span>;
        <span class="comment">//验证是否成功返回</span>
        Assert.assertEquals<span class="params">(<span class="literal">true</span>, succ)</span>;
        <span class="comment">//验证user中获取到到的对象就是Mock返回的对象</span>
        Assert.assertSame<span class="params">(expectedUser, user.get<span class="params">(<span class="string">"user"</span>)</span>)</span>;
        <span class="comment">//验证getUserInfoData()的调用只发生了一次</span>
        Mockito.verify<span class="params">(dbService)</span>.getUserInfoData<span class="params">()</span>;
    }
}
</code></pre><p>以上就是Mock的简单应用，一般的单元测试场景这已经足够使用了，如果需要了解更多Mock使用，可以进一步在<a href="http://mockito.org/" title="Mockito" target="_blank" rel="external">http://mockito.org/</a>进行学习。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  

        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="YIDI" />
          <p class="site-author-name">YIDI</p>
        </div>
        <p class="site-description motion-element">JEE Dadabase BigData Hadoop Spark</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">2</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/yidi" target="_blank">github</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/zelinan" target="_blank">weibo</a>
            </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">Links</p>
            
              <span class="links-of-author-item">
              <a href="http://info.ruc.edu.cn/" target="_blank">RUC INFO</a>
              </span>
            
          
        </div>
        
      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="author">YIDI</span>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.3"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.3"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.3" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"yidi"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  

</body>
</html>
